#### 八股：

##### cpp

###### 1.智能指针是什么？本质是什么

答：

智能指针是c++中的一种封装指针的类，用于自动管理动态分配的内存，避免内存泄露，悬挂指针等问题。本质是一个类磨盘

**unique_ptr**

独占所有权，某个动态分配的对象在同一时刻只有一个unique_ptr指向。析构时会删除所管理的对象，防止内存泄露。禁止拷贝赋值，但是有移动构造函数。

效率高，没有额外开销，不需要维护引用计数。

**shared_ptr**

共享所有权的指针，多个shared_ptr对象可以共同管理一个动态分配的对象，最后一个shared_ptr被销毁或者重置时，对象会被自动删除。

（底层实现原理是什么）

###### c++中的RALL机制

range_based for loop 基于范围的for循环和lamdba表达式一起使用，简化容器的遍历。

简化遍历容器的操作； 允许定义匿名函数对象，简化函数的使用

###### RAII（Resource Acquisition Is Initialization）***

是一种在C++中广泛使用的编程惯例，它通过将资源的管理与对象的生命周期绑定在一起，确保资源的自动释放和异常安全。RAII的核心思想是：**资源的获取（分配）与对象的初始化挂钩，资源的释放（释放）与对象的销毁挂钩**。

###### 2.构造函数能不能设置为虚函数

虚函数的机制依赖于虚函数表，构造函数的执行过程发生在对象创建时期，此时虚函数表尚未初始化。

虚函数表是在对象构造过程中生成和初始化的。

注意：

静态成员函数也不能被设置。因为静态函数是与类本身关联，而不是具体对象，没有虚函数表，无法设置。

###### 3.虚指针是什么

虚指针（通常称为**vptr**）是实现虚函数机制的一个重要概念。虚指针是一个指向虚函数表（vtable）的指针。每个包含虚函数的类都有一个虚指针，虚指针指向一个虚函数表，该表包含了该类的所有虚函数的地址。

每个对象都有一个虚指针。

###### 4.什么是菱形继承，如何解决菱形继承

菱形继承（Diamond Inheritance）是指在多重继承中，派生类从多个基类继承，而这些基类又有一个共同的祖先类。这种继承结构看起来像一个菱形，因此得名“菱形继承”。菱形继承会引发一些问题，特别是在对象模型中可能导致二义性和不必要的重复。

C++ 提供了**虚拟继承**（Virtual Inheritance）来解决菱形继承中的这些问题。虚拟继承确保基类的子对象只存在一个副本，而不是多个副本。

###### 5.快速排序，堆排序时间空间复杂度

###### 6.c++程序编译的四个流程

- 预处理，

- 编译，

- 汇编，

- 链接

- ###### 7.栈溢出的情况


- 递归过深。嵌套，
- 局部变量占用过多空间，比如声明很大的数组
- 不正确的指针
- 不合理的循环

###### 8.模板的全头包和偏头包

**全头包**（Header-Only）是指将模板的声明和实现都放在头文件中，这意味着头文件不仅包含类或函数的声明，还包含所有模板函数或类成员的实现。因为模板的实现需要在**编译**时实例化，所以通常要求模板的实现必须和声明放在一起，或者至少在同一个文件中能被找到。

**偏头包**（Split Header/Implementation File）是指将模板的声明和实现分开，声明部分放在头文件中，模板实现放在源文件（通常是 `.cpp` 或 `.tpp` 文件）中。为了使模板在其他源文件中可以使用，通常需要在**头文件中包含实现文件**，或者在实现文件中显式实例化需要的模板类型。

###### 9.vector和list

vector：底层时连续的。快速随机访问，动态扩展，插入删除慢

list：双向链表，访问慢，插入删除快

###### 10.new和malloc

动态内存分配，在堆中分配

new类型安全，自动类型转换，自动调用构造和析构函数，失败抛出异常，delete释放，在c++中更安全

malloc只会分配内存，free释放

new的工作流程：1.调用malloc分配内存 2.在malloc分配的内存上调用构造函数进行初始化 3.返回初始化的指针。提供了比malloc更高级的功能，包括类型安全和构造函数的调用。

###### 11.多态的实现原理

- 静态多态（函数重载和模板）编译时确定

- **动态多态**：运行时确定，比如虚函数和继承，纯虚函数和抽象类，
- 多态的底层实现原理

类的对象被创建时，如果类有虚函数，编译器会在对象的内存布局中添加一个虚指针，构造函数初始化这个指针，指向类所属的虚函数表

当基类指针引用或者调用虚函数时，编译器会生成代码。1.通过对象虚指针找到虚函数表 2.在虚函数表中找到虚函数地址 3.调用该地址处的函数。

###### 12.指针和引用

###### 13.static关键字

- 修饰全局变量
- 修饰局部变量
- 修饰函数
- 修饰类成员变量和函数

###### 14.c++11新特性

右值引用，移动构造，auto等

###### 15.struct和union

**结构体**是一种自定义的数据类型，可以包含不同类型的数据成员。每个数据成员在内存中都有独立的存储空间。结构体用于将相关的数据组织在一起，使得处理和传递这些数据变得更加方便。

**共用体**是一种特殊的数据类型，它允许多个数据成员共享同一块内存空间。所有成员共用同一段内存，只有一个成员在任意时刻有效。共用体用于节省内存，当多个成员不同时使用时，共用体能减少内存占用。

###### 16.define和const

**define**是预处理指令，定义变量或者创建宏函数，编译时允许并且替换代码中对应的内容。没有类型，无法进行类型检查，全局，不支持作用域，不支持调试

const是关键字，用于定义常量变量，确保值在初始化之后不可改变，可以用于基本数据类型，指针，对象等。

###### 17.迭代器失效

**vector扩容**：

- 插入/删除：末尾插入在容量没达到限制的情况下不影响，中间插入或者会导致该位置以及之后的迭代器全部失效。
- 重新分配内存：所有现有的迭代器和指针将失效，因为容器的底层数组被重新分配到新位置。
- 在插入或删除元素前，如果需要保持迭代器有效，可以使用`reserve`来预先分配足够的内存，以减少重新分配的可能性。
- 使用`std::deque`或`std::list`可以避免因重新分配内存而导致的迭代器失效。

由于对容器的修改操作（如插入、删除、重新分配内存等），可能导致先前获得的迭代器变得无效或不再指向有效的元素。这会导致程序错误或未定义行为。

###### 18.extern

用于知识变量或者函数定义在另一个源文件中，并且在当前函数声明

###### 外部链接，内部链接，无链接

###### 19.命名空间

代码组织工作。将相关的标识符分组在一起，避免命名冲突。

###### 20.单例模式，常见的设计模式

###### 21.STL

数组，链表，红黑树，B+树（严格的平衡二叉树）

###### 22.array,list,哈希表。

###### 23.内存泄露

内存泄漏（Memory Leak）是在程序运行过程中分配了内存但未能正确释放，从而导致内存资源被浪费的情况。在C++中，内存泄漏通常发生在动态内存分配时。内存泄漏会导致程序使用的内存不断增加，可能最终耗尽系统的可用内存资源，从而导致性能下降或程序崩溃。

- 没有delete
- 覆盖指针
- 在动态分配内存后发生异常，如果没有适当的异常处理机制，可能会导致内存泄漏。
- 在使用智能指针（如 `std::shared_ptr`）时，循环引用（即两个或多个智能指针相互持有对方的引用）可能导致内存泄漏，因为它们会永远保持对彼此的引用，无法释放

###### 24.四种类型转换



###### 25.b+树和红黑树的区别，结构，应用场景

###### 26.volatile关键字的作用和使用场景

###### 27.malloc的底层机制



##### 操作系统

###### 1.进程间通信方法有哪些

管道，消息队列，共享内存，

信号量，socket

###### 线程间通信

###### 多线程间的异步，同步

###### 2.锁的原理，加锁，自旋锁，死锁的产生和避免

###### 3.虚拟内存是什么

###### 4.精简指令集和复杂指令集

###### 5.cpu处理指令的流程

###### 6.如何保证线程安全

###### 7.内存分区

###### 8.描述一下线程池

###### 9.进程同步，异步，阻塞呢非阻塞***

###### 10.进程和线程关联

###### 11.linux的内存池，如何管理内存

###### 12.一个进程占用了系统中的哪些资源？

###### 13.进程中断时发生了什么

###### 14.原子操作和互斥

###### 15.物理内存和虚拟内存

###### 16.孤儿进程和僵尸进程

###### 17.进程上下文切换

###### 18.linux的常用命令



##### 计网

###### 1.三次握手四次挥手

###### 2.向已经关闭的tcp连接发生数据

###### 3.TCP通信协议的理解

###### TCP丢包

###### 滑动窗口

###### 超时重传时间选择

###### 拥塞控制

###### 4.UDP

###### 5.http

###### 1.0 2.0 3.0

###### http和https

###### https加密流程

###### get，head，post，put，delete

###### 状态码

###### cookie和session

###### 6.socket编程

###### http状态码

###### 7.IO复用:select，poll，epoll

###### 8.

###### 9.网络模型

###### 10.为什么有了ip还要MAC

###### 11.输入一个URL到显示页面全过程

###### 12.DNS为什么时UDP



##### 其它

###### 1.B+树索引，哈希表索引

###### 2.事务的ACID，事务并发，事务隔离级别

###### 3.MCVV，多版本并发控制实现机制



#### 简历项目：

###### webserver

http，tcp，udp

pool





#### 有待提高：

1. 针对c++等一些新特性，需要做个mytinystl的项目补足一下。
2. 只学c++的话范围有限，可以做个go的分布式缓存的项目，大概c++辅go这种。
3. 需要几个c++的难度比较高的项目保底。

###### 需要将c++，计网，os的知识过的更加全面

###### 回顾之前的学习笔记

