v<img src="E:\1\5.jpg" style="zoom:40%;" />



[Go语言圣经 - Go语言圣经 (gopl-zh.github.io)](https://gopl-zh.github.io/)

[7天用Go从零实现Web框架Gee教程 | 极客兔兔 (geektutu.com)](https://geektutu.com/post/gee.html)

[Go 语言项目开发实战 (geekbang.org)](https://time.geekbang.org/column/intro/100079601)



### C++&Golang



1. **变量**。c++中一般只有全局变量会声明时会自动让其为0或者空，局部变量声明时必须对其初始化分配空间。但是在go中，只要声明了就会自动为其分配nil或者空，不需要再自己初始化。

2. go在处理**并发**的时候有很多已经封装好了的包，相比c++需要自己一步步实现方便很多。

3. **返回函数中的局部变量。**c++中你如果这么做的话，就是乱写），因为函数在结束时会释放其中的局部变量，这样会导致返回值是错误的。但是go增加了**逃逸分析和垃圾回收机制**。

   - **逃逸分析**：

     - Go 语言的编译器在编译期间会进行逃逸分析。这是一种分析方法，用来确定某个变量的内存分配是在栈上还是在堆上。

     - 如果局部变量的地址在函数外部被引用（例如通过返回指针或闭包），编译器会判断该变量可能在函数结束后仍然需要被访问，这时它会将该变量分配在堆上，而不是栈上。

   - **垃圾回收**:

     - Go 语言有自动垃圾回收机制（Garbage Collection, GC）。对于分配在堆上的变量，当没有任何引用指向该变量时，垃圾回收器会自动回收这块内存。因此，即使局部变量被分配在堆上，它也不会在函数返回时立即被释放，而是由垃圾回收器在合适的时机回收。
     - 基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

   ​       Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。（该段来源：[变量 - Go语言圣经 (gopl-zh.github.io)](https://gopl-zh.github.io/ch2/ch2-03.html)）

4. **指针。**c语言中如果你用`*p++`，这个是指针的移动，但是go中指针不会移动，可以理解成为原变量创建一个新的别名，而不是c中指向变量的首地址的含义。

5. 这字符串，数组之类的用法跟python还有点像），果然只有c和c++最为原始。

6. 如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在**Go语言中，所有的函数参数都是值拷贝传入的**，函数参数将不再是函数调用时的原始变量。

7. Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。**匿名成员**的数据类型必须是命名的类型或指向一个命名的类型的指针。

8. 偶然看到的文章：[面试](https://mp.weixin.qq.com/s/Yoe9SRLuxk1GNKAjGVWUfQ)。简单记录一下有用的，方便后面学习。

   **c++和golang的区别：**

   - 语法复杂性：

     c++语法相对复杂，支持多种编程范式，有模板，多重继承等高级特性。

     Go语法简洁，易于学习，避免了一些复杂的特性，比如类继承。

   - 性能：

     c++更精密，提供接近硬件级别的性能，适合需要高性能计算的场合。

     go性能不如c++，但适用大多数场合，尤其是在并发和网络服务方面。

   - 内存管理：

     c++需要手动内存管理，使用new和delete操作符，或者智能指针等

     go有自动垃圾回收机制，逃逸分析机制等，简化内存管理，但不支持传统的指针算术。

   - 并发编程：

     c++11开始支持线程和并发，但是并发编程相对复杂

     go原生支持并发，使用goroutines和channels，使得并发编程更加简单安全。

9. **Go 的错误处理机制**提倡明确、清晰的错误处理方式，鼓励开发者主动检查和处理错误。这种机制使代码更加可靠，也更易于理解和维护。通过使用内置的 `error` 接口、自定义错误类型和错误包装机制，开发者可以有效地管理程序中的错误。

10. **可变参数**比数组更灵活，在函数内部类似切片，动态分配内存。

11. **defer**也是一个好玩的关键字，在资源清理，日志记录，文件关闭等场景中非常有用，可以延迟函数或者方法的执行，直到包含它的函数返回时才会执行。

12. **panic异常**

    - panic通常用于处理严重错误，比如程序无法恢复的错误，或者是不应该发生的逻辑错误。

    - 与defer一起可以在崩溃前执行一些清理工作。defer中可以再用recover，可以祈祷捕获的作用。

      **recover**主要作用是截获panic引发的运行时一场，从而防止程序崩溃。只有在defer中才会生效。

13. go中，方法可以定义在结构体类型的**值接收者或者指针接收者**上。

    - 值接收者：go始终得到的是副本。
    - 指针接收者：go将结构体的指针传递给方法，就可以直接对原结构体进行修改。

14. go语言中**切片，映射，接口**等数据结构的实现原理。

15. go的接口类型和泛型有什么区别。

16. go的版本特性。

17. **go的好处：**
    golang对于并发进行了优化，在规模上运行良好，比其它语言更具有可读性，自动垃圾回收机制，panic异常，错误处理机制等都可以使得代码运行中安全性更强。

18. **如何理解Go中的接口inferface和方法method。**

    **inferface：**一组方法的集合，但是不包含方法的实现。可以定义方法的签名，具体的实现由接口的类型提供。接口可以实现多态。

    **method：**方法是与某个类型相关联的函数。方法的定义和普通函数相似，但它们都有一个接收者，即方法绑定到哪个类型上。

19. **Gorountines和Channels**

    **Goroutine：**Go语言中的一个轻量级线程，执行函数的一个并发单元。

    **Channel：**Go语言中用于Goroutine之间进行通信和同步的机制，提供了一种安全的方式传递数据，避免了传统的锁和共享内存的复杂性。

    

[golang入门面试题](https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/1.Go%E5%85%A5%E9%97%A8.html)



待办

[代码随想录go项目精讲 | 代码随想录 (programmercarl.com)](https://programmercarl.com/other/project_go.html#下载方式)