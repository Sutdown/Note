## go入门学习

> 常见问题：
>
> - **go中select+channel（goroutine）的实现机制**
>
> - **GC垃圾回收原理**
>
> - 内存模型
>
> - goroutine，**GMP**调度机制，调度流程
>
> - CHAN原理，Context原理
>
> - 竞态，内存逃逸
>
> - 侵入式和非侵入式
>
> - ###### defer+recover+panic，以及相应底层原理
>
> - 方法的特别之处
>
> - 接口的作用和底层原理
>
> - slice，**map原理**，为什么它们都是非线形安全的
>
> - 反射高级编程

### 1 设计理念

#### go是一门面向对象的语言吗

以下为官方回答：

是的，也不是。原因是：
Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。
Go 中的 “接口 “概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。
Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、“未装箱的 “整数。它们并不局限于结构（类）。
Go 由于缺乏类型层次，Go 中的 “对象 “比 C++ 或 Java 等语言更轻巧。

#### go的设计理念

go是一种基于连接（结构）与组合的语言。

go的设计理念在于工程化，更好直接的提升项目的效率。因此在并发上的封装尤其的多（比如goroutine)，同时为了语法的简明，去形成了一套完整的垃圾回收，内存模型，异常与错误（defer+panic+recover）等机制。不同于c++面向对象编程，封装继承多态三大特性的语言性质，go使用组合方法接口达成一套新的机制。

**优点：**

1. 一种支持**垃圾回收**、静态编译的系统级编程语言
2. Go对**并发(concurrency)和并行(parallelism)**的原生支持有助于利用当时正在成为主流的多核机器的优势
3. Go没有提供类(class)，但允许将方法(method)绑定到任何类型上，包括结构体、数组、切片、map，甚至是基本类型，如整型。它没有类型层次体系；我们认为继承性往往会使程序在演化过程中更难适应。相反，**Go鼓励类型的组合**。
4. Go通过其接口类型提供面向对象的多态性。任何Go类型如果拥有与某个接口相同名称和签名的方法集合，就被认为是实现了该接口，而无需额外的显式声明。



### 2 复合数据类型（数组，slice，map）

#### 数组

1. 当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；
2. 当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；



### 3 方法



### 4 接口



### 5 协程（GPM调度和CSP模型）



### 6 并发



### 7 内存分配 

内存管理一般包含三个不同的组件，分别是**用户程序（Mutator）**、**分配器（Allocator）**和**收集器（Collector）**，当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。



#### 内存分配器

编程语言的内存分配器一般包含两种分配方法，一种是线性分配器（Sequential Allocator，Bump Allocator），另一种是空闲链表分配器（Free-List Allocator）。Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。



TCMalloc 和 Go 运行时分配器都会引入**线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）**三个组件分级管理内存。

> 三个组件分别有什么作用
>
> 线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，运行时会使用中心缓存作为补充解决小对象的内存分配，在遇到 32KB 以上的对象时，内存分配器会选择页堆直接分配大内存。



#### 虚拟内存布局

在 Go 语言 1.10 以前的版本，堆区的内存空间都是连续的；但是在 1.11 版本，Go 团队使用稀疏的堆内存空间替代了连续的内存，使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题。

> 为什么这里会出现C和Go混用的地址空间冲突问题

所有的 Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会分配一个线程缓存 [`runtime.mcache`](https://draveness.me/golang/tree/runtime.mcache) 用于处理微对象和小对象的分配，它们会持有内存管理单元 [`runtime.mspan`](https://draveness.me/golang/tree/runtime.mspan)。

当内存管理单元中不存在空闲对象时，它们会从 [`runtime.mheap`](https://draveness.me/golang/tree/runtime.mheap) 持有的 134 个中心缓存 [`runtime.mcentral`](https://draveness.me/golang/tree/runtime.mcentral) 中获取新的内存单元，中心缓存属于全局的堆结构体 [`runtime.mheap`](https://draveness.me/golang/tree/runtime.mheap)，它会从操作系统中申请内存。





### 8 垃圾回收

#### 垃圾回收的五种经典算法

##### 标记-清扫

比如经典的三色标记算法。主要缺点在于可能产生内存碎片或者空洞导致新对象分配失败。

##### 标记-压缩

减少内存碎片，增加复杂度。

##### 半空间复制

空间换时间

##### 引用计数

无法解决并发，只能原子操作

##### 分代GC



#### Go语言采用并发三色标记算法进行垃圾回收

为什么不选择压缩GC  ——  TCmalloc内存分配

为什么不选择分代GC  ——  内存逃逸



##### Go垃圾回收演化

Go1.0 单协程垃圾回收

Go1.1 多协程垃圾回收

Go1.5 用户协程和后台的垃圾回收同时进行

Go1.6 大幅减少STW期间的任务

Go1.8 采用混合写屏障技术消除栈重新扫描的时间



##### 垃圾回收的阶段

```txt
触发垃圾回收 ---> 标记准备阶段 ---> 并行标记阶段 ---> 标记终止阶段 ---> 垃圾清扫阶段
     |                                                             |
     ---------------------------------------------------------------
```

标记准备阶段

重置各种状态和统计指标、启动专门用于标记的协程、统计需要扫描的任务数量、开启写屏障、启动标记协程等。



### 9 反射



### 参考书籍

1. 《go底层原理剖析》（内容讲解比较通俗）
2. [go语言圣经](https://golang-china.github.io/gopl-zh/index.html)（经典书籍，存在一定难度）
3. [go语言之旅](https://tour.go-zh.org/welcome/1)（有代码讲解，最为简单，适合初步学习）
4. [语言环境 | Go 语言设计哲学](https://golang3.eddycjy.com/posts/go-env/)（可浏览，很有意思）
