# MySql实战45讲笔记 --- 实践篇



#### 普通索引和唯一索引

- 普通索引：找到满足条件的第一个记录之后，会查找下一个记录，直到不满足要求。
- 唯一索引：查找到第一个满足条件的记录后，就会停止继续检索。

两种索引的性能差距微乎其微。当需要读一条记录的时候，以页为单位，整体从磁盘读入内存。在InnoDB中，每个数据页的大小默认16KB，当找k=5的记录，它所在的数据页就都在内存里，对于普通索引，要多做一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算；如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。

> change buffer：当更新数据页时，如果数据页不在内存中，不影响数据一致性的情况下，innoDB会将该更新操作缓存在change buffer中，下次需要访问该数据页时，将其读入内存，执行change buffer中与这个页相关操作。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。**唯一索引的更新就不能使用change buffer**，因为唯一索引一定要读入内存看有没有冲突，普通索引则是会将更新记录在change buffer，减少了磁盘的随机访问，提升部分性能。

*举个例子：*

*某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，这个业务有大量插入数据的操作，而某员工在前一天把其中的某个普通索引改成了唯一索引*

change buffer使用较好的场景是写多读少，比如账单累，日志类。它在读时容易触发merge过程，频繁的读操作不会减少访问IO的次数，反而增加了change buffer的维护代价。



Q：change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了merge过程，就等于是数据丢失了。

A：虽然是只更新内存，但是在事务提交的时候，我们把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来。



#### MySQL为什么有时候会选错索引

选择索引是优化器的工作。优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。

既然是统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。

解决方案：

- **采用force index强行选择一个索引。**
- **修改语句，引导MySQL使用我们期望的索引。**
- **新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。**

[为什么会选错索引](https://jums.gitbook.io/mysql-shi-zhan-45-jiang/10-mysql-wei-shi-mo-you-shi-hou-hui-xuan-cuo-suo-yin)



#### 如何给字符串字段加索引

1. 直接创建完整索引，这样可能比较占用空间；
2. 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
4. 创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。
