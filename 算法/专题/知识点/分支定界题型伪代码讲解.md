# 有关分支定界思想的题型伪代码讲解



#### **分支定界的关键在于：广度优先搜索和优先队列的优先法则。**



依次，拿具体题目来看看。

## 1.[货箱装载问题]

> 考察如下货箱装载问题：有⼀批共个集装箱要装上2艘载重量 分别为C1和C2的轮船，其中集装箱i的重量为Wi，装载问题要求确定是否有⼀个合理的装载⽅案可将这些集装箱装上这两艘轮船，若 有，找出⼀种装载⽅案。编写⼀个分⽀界限算法，搜索可⾏⽅案。（伪代码即可）

**限界函数**：每艘船的装载量不能比轮船的载重量要大。

**状态空间树**：采用的是子集树。

**伪代码**：这个题的伪代码是一个很基本的代码思路。

初始化—>循环开始—>装载左右子树（左子树状态有条件）—>取扩展结点，取到则进入下一层同时装载到队列，没有取到退出循环—>多次循环从循环开始的步骤，直到队列遍历完或者找到解决方案，该算法结束。

这个-1的设置，是在扩展树的时候，对于第i个集装箱放或者不放的一个标志。因为递归树并不是一下子建好的，而是在结点的扩展过程中一步步建立，所以需要记住是到达了第几个集装箱的状态。

至于两艘船的体现在于，改代码

```cpp
Ew=0,Q.add(-1),i<-1 //初始化当前节点的集装箱重量为0，将-1添加到队列中作为标志，初始化i为-1.
while true
    先检查左子树
    if Ew+w[i] <= c
        装载左子树进入队列
    装载右子树进入队列
    Q.Delete(Ew) //取下一个扩展结点
    if Ew == -1
        if Q为空 then 算法结束
        Q.add(-1) //将-1加入，作为同层节点的尾部结束标志
        R.Delete(Ew) //取下一个扩展结点
        i<-i+1 //循环进入下一层
```



## 2.[n 皇后问题]

> 在n 皇后问题中，我们希望在n×n 的棋盘上找到⼀个n 皇后的放置⽅法以便任意两个皇后之间不冲突。当且仅当两个皇后在相同的排、列、 对⻆线或反对⻆线上时，她们之间将发⽣冲突。假定在任何可⾏的解决⽅案 中，皇后i 被放置在棋盘的第i 排。所以只对决定每⼀个皇后所在的列感兴 趣。令ci为皇后i 所处的列。如果任意两个皇后不冲突，则 [c1,c2, ⋯ , cn ]是 [1, 2, ⋯ , n]的⼀个排列。n 皇后问题的解空间因此被限制到[1, 2, ⋯, n]的所 有排列中。编写⼀个FIFO分⽀限界算法，搜索n皇后问题的可⾏排列。（编写伪代码即可）

**限界函数**：每个位置的皇后不冲突。

**状态空间树**：采用的是排列树。这里巧妙的是排列树不再是层层遍历，而是通过交换的操作去验证不同的排列，实际上也相当于在搜索空间中进行着深度优先搜索，搜索失败交换也会及时撤销继续尝试其它的排列。

**伪代码**：

宽搜的实现：for->nQueen->for刚好是在同一层。

如果是这个从头到尾依次交换，也能说是体现了先进先出的思想。限界函数的位置大概是在for循环的if语句中，但其实没有写清楚。

初始排列应该是一条斜线。

```cpp
Def nQueen(n, t, pieces[])
    if t > n \\得到合理解决
        输出解决方案
    else
        for i←t to n
            //第t行跟后面的所有行换，也是将排列树的思想到位了，也类似于宽搜
            swap(pieces[t], pieces[i]);//探索可行性
            if 当前行可行 then nQueen(n, t + 1, pieces);//继续搜索
            swap(pieces[t], pieces[i]);
```



## 3.[顶点覆盖]

> 已知G为⼀个⽆向图。给定⼀个G的⼀个顶点⼦集U，当且仅当G中 的每⼀条边必有⼀个顶点属于U或者两个顶点都属于U时，称U是G的⼀个顶 点覆盖（vertex cover），U中顶点的数量是覆盖的⼤⼩(size)。编写⼀个最⼩耗费分⽀限界算法寻找最⼩的顶点覆盖，并确定算法的复杂度。

编不下去，各位跳过这道题。

这代码思路是选择一条边，然后去除和该边相连的边，这个思路比较像贪心。

如果是按照分支限界的

**伪代码**：

```cpp
VertexSet approxVertexCover ( Graph g )
    cset=空集；
    e1=g.e；
	while (e1 != 空集)
		从 e1 中任取一条边(u,v)；
		cset←cset∪{u,v}；
		从 e1 中删去与 u 和 v 相关联的所有边；
	return c
```



## 4.[简易最大分割]

> 已知G是⼀个⽆向图，令U是G中顶点的任意⼦集。令V是G中 剩余顶点的集合。这样⼀来，U便把G的顶点做了⼀个切割(cut),⼀部分属于U， 另⼀部分属于V。⼀个端点在U中，另⼀个端点在V中的边的数量表示切割的⼤ ⼩。编写⼀个最⼤收益分⽀限界算法，寻找最⼤切割的⼤⼩和相应的⼦集U。（编写伪代码即可）

初始化+循环（在队列中加入结点（记得约束条件），再取出队首元素）。

```cpp
Def search()
	初始化 ：层 0 割边 0 剩余边 e
	for j←1 to n
		enode.x[j] = 0;//解向量
	int best = 0;//最大收益初始化

	//分支限界求解
	While(true)
	If 到达叶子节点，如果比当前最优解更优
		更新
	else//没有到达叶子节点
		addNode(enode);//加入左子结点
		If enode.cut+enode.e>best//满足约束条件，加入右子结点
			addNode(enode);
		If 节点遍历完毕 then break;
		else 取出队首元素
	return best;
}
```



## 5.[旅行商问题]

> ⼀个售货员必须访问n个城市，恰好访问每个城市⼀次，并最终 回到出发城市。售货员从城市i到城市j的旅⾏费⽤是⼀个整数，旅⾏所需的全部 费⽤是他旅⾏经过的的各边费⽤之和，⽽售货员希望使整个旅⾏费⽤最低。n个 城市（n=5）的编号及城市⻅的旅⾏费⽤如下图所示，假设旅⾏商初始在位置 0。请编写⼀个最⼩费⽤分⽀限界算法求解他的旅⾏路径。（编写伪代码即可）

这个伪代码采用的是规约矩阵的思路。

```cpp
建立一个 heap,存储状态，出堆规则为拥有最小的下界。
利用 reduced cost matrix 来把矩阵进行化简，把化简消耗作为下界，将初始状态加入 heap
While heap is not empty
	从 heap 中弹出一个状态，赋值给两个临时状态。
	If 该状态的下界大于等于全局上界
		return 
    遍历所有边，选择删除则引起下界上升最大的边
	If 使用该边
		更新下界
		If 已经遍历所有城市并回到了起点且小于等于全局上界
			记录该状态，更新全局上界
		Else 
    		将该弧所对应的整行和整列赋值为 Infinite 
    		将当前的边的反向弧赋值为 Infinite 
    		在结果集中记录该弧，将状态加入 heap
		否则 在 matrix 中将该弧赋值为 Infinite,更新下界，将状态加入 heap
    
答案：0->1->4->2->3->0，最小值为：23
```

