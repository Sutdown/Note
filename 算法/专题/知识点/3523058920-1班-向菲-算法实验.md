# 针对0/1背包的三种算法思路

​                                                                                                    ——智能与计算学部   大类1班   3523058920向菲

​                                                                                                    ——算法分析与设计上机实验



[TOC]

## 一：摘要



本文针对01背包问题，分别从动态规划，回溯，分支定界三个算法的视角对该题的解题思路进行分析，同时进行代码的实现和验证。然后对三种方法进行比较分析。在三种方法之中，会从解题思路，算法实现，算法分析的角度和该题进行联系。注重讨论算法能够适用于该题的原因和不同算法之间的优劣性。

动态规划从题目开始，点名题目特点以及能够使用动态规划的原因，然后找到相应的状态转移方程，对算法的实现进行递归和非递归两种方式呈现，最后进一步分析代码在空间上优化的可能性，依次完善整个dp的思路。

回溯和分支定界均在建立完整的解空间后，采用一定的搜索方式，比如增加约束函数或者限界函数对解空间树进行优化，不必要结点的遍历可以不用遍历，回溯关键在于深搜，分支定界在于广搜，根据搜索方式的不同选择合适的限界函数对搜索进行优化，同时由于具体搜索方式的差异，本文会对时间复杂度，空间复杂度，适用情形等多角度进行分析。

关键词：0/1背包，动态规划，分支定界，回溯

## 二：实验选题

### 2.3    问题求解类

针对附件 1 中某一问题的至少 2 个数据集，利用动态规划、回溯及分支限界三种算法进行求解 。要求：分析不同算法解决同一问题的复杂度，归纳不同求解算法的优缺点。

#### 选题

2.3中选择对0/1背包问题，利用DP，回溯，分支限界三种算法求解同时进行分析，选取三个数据集对算法进行验证。

数据集来自：•  Florida State University: 8 个数据集。[Link](https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html)



## 三：实验流程

（正文仅显示关键代码，完整代码见附录）

> **01背包问题**
>
> 背包固定容量为V。 我们还得到了N个对象的列表，每个对都有一个体积Vi和利润 Wi。 我们可以将任何对象的子集放入背包中，只要总数我们选择的重量不超过C。我们希望实现总利润最大化， 这是我们放入背包的每个物体的利润总和。
>
> 因此，01背包问题的解是 N 个对象的子集S其权重总和小于或等于C，并且使总利润最大。

对于该题，每件物品有选择和不选择也就是0和1两个特性，**暴力**做法的时间复杂度在O(2^n)。

那么解决这种问题有种直观的方法就是从所有的解空间中寻找到它的最优解，也就是下文对应的**回溯和分支限界**两种专门解决搜索问题的算法。但若是不是直接看问题的解，而是观察解决这个问题的思路，可以发现对于每个背包选择和不选择的方法是相同的，解空间中也存在相同的子树，因此数组保存前一步的结果，循环解决整个问题的思路就是**动态规划**。



### 3.1动态规划 

题目可以用动态规划解决的经典特征是**重叠子问题**和**最优子结构**。

#### 3.1.1dp和非递归算法

这个问题明显可分为子问题，然后我们寻找大问题和小问题的解决方案。

若dp(i)(j)指的是在容量为j时有i件物品的最好价值，那得到以下**状态转移方程**：
$$
dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i])
$$
这个是根据第i个物品在0和1的状态中所得到的方程，如果第i个没有被选择，那么它与i-1时的结果相同，如果它被选择了，我们取一个刚好完全将背包放满的情况的i-1时的值加上当前值的结果，这是在求dp(i)(j)时的方法。

```c++
int dp[MAXN][MAXN];
int N,V;//物品数量，总容量
int v[MAXN],w[MAXN];//单件体积，单件价值

for(int i=1;i<=N;i++){
	for(int j=1;j<=V;j++)
		if(j>=v[i])dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);
		else dp[i][j]=dp[i-1][j];
}	
cout << *max_element(dp[N]+1,dp[N]+V+1) << endl;
```

##### 滚动数组为其优化（写法和思路类似元组法）

时间上已经达到O(n^2)，已经优化过，但是我们还能从空间上尝试进行优化。

观察上述状态转移方程，第i行的dp数组都是由i-1行中的数据得到的。那么可以不用第一维度也就是[i]的维度，再观察j，j也是从小到大的，所以在求dp(j)的时候，已经把第i-1行的dp(j)更新了，求dp(j+w(i))的数据时必然出错了，它得到的是i行的dp(j)而不是i-1行，逆序让j从大往小，j变小也不会有前面数据在用到后面的数据了（dp(i)(j)的求法是在上面和左上，不会用到右侧的数据）。

```c++
for (int i = 1; i <= N; i++) {
		for (int j = V; j >= 1; j--)
			if (j >= v[i])dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
	}
cout << dp[V] << endl;
```



若要判断背包中物品的装入状态，还是应该用二维数组回溯判断，当发现该物品被选择时，用数组记录下来，然后继续回溯，直到到最后。

```c++
	vector<int> items;
	for (int i = N, j = V; i > 0; i--) 
		if (choice[i][j] == 1) {
			items.push_back(i);
			j -= v[i];
		}
```

在这之中，时间复杂度均为O(n^2)，滚动数组的思想降低了一定的空间复杂度。



#### 3.1.2dp和递归算法

递归相较于非递归是一种更为直观的解决方式，但是效率较低。在逐层向内递归的过程中，不仅会占用更多的空间，也会重复计算子问题。非递归的循环中采用了记忆化搜索的技术，更加高效，因此更建议非递归的处理方式。

```c++
int knapsack(int i, int j) {
	if(i == 0 || j == 0) {
		return 0;
	}
	if(dp[i][j] != -1) {
		return dp[i][j];
	}
    
	if(j < v[i]) {
		choice[i][j] = 0;
		return dp[i][j] = knapsack(i-1, j);
	} else {
		int value1 = knapsack(i-1, j);
		int value2 = w[i] + knapsack(i-1, j-v[i]);
		if(value1 > value2) {
			choice[i][j] = 0;
			return dp[i][j] = value1;
		} else {
			choice[i][j] = 1;
			return dp[i][j] = value2;
		}
	}
}
```

问题规模为n，每次递归的计算复杂度为O(1)，则时间复杂度为O(n)。

和前面的非递归来比较，相当于空间换时间。



#### 3.1.3元组法

<img src="C:\Users\向菲\AppData\Roaming\Typora\typora-user-images\image-20231129211557280.png" alt="image-20231129211557280" style="zoom: 33%;" />

如该图所示，元组法指的是在每选择是否放入一个物品时，在1-V的容量的情况下，能放就更新相应对应的容量，不能放就不更新。如上图中每个物品的每个容量都会存储，但再次观察，在每行出现了连续的值，这些值的意思是在这个容量范围内从前到后刚好都能存放，所以实际上只需要存储连续的数的第一个也就是关键数据即可。最后得到的dp[N]也就是最好的结果。

这也相当于遍历了每一种可能性。

```c++
for(int i = 1; i <= N; i++) 
	for(int j = V; j >= v[i]; j--) 
		if(dp[j] < dp[j-v[i]] + w[i]) {
			dp[j] = dp[j-v[i]] + w[i];
			choice[i][j] = 1;
		}
```

时间复杂度为O(nV)。



### 3.2回溯

这里是采用一种对于未来的预测，也就是保存bestcw，同时对未来将要遍历的节点做出判断，假设背包中的物品可划分时会造成的最好最好结果bound（也就是先将所有密度最大的装入），如果这个结果比bestcw要小，那完全没有继续遍历该子树的必要。

因此可以得出

1）需要将背包中的物品按照密度从大到小排序，便于计算。

2）每个节点最重要的要保存的数值是当前获益cp（当前最好容量），未来可能的最大容量bound（剩余容量）从而画出递归树进行判断，未来最好容量要大于当前最好容量才能向下遍历。

3）所有的遍历到最后时，再回溯。

代码思路：可以借助一个物品的结构体为密度排序的同时排序重量和价值。结构体重包含物品重量、价值和密度，定义仿函数用于密度排序物品。接着定义了一个回溯函数，用于搜索所有可能的解，并记录下最大价值和对应的物品。最后在主函数中调用了这个回溯函数，并输出了最大价值和对应的物品。

```c++
//简略的伪代码：
按照密度对物品排序
bestp <- -∞
设x=(x(1),x(1),x(3)......x(k))为当前E节点(bound>bestp成立)

if i>n bestv=cv,保存最好状态;//递归出口
展开左子节点
if cw+w(k) <= c
    	//装入物品k
   下一层递归：i+1，cw+w(k),cp+p(k)
      	 x(k)=1
if bound > bestv then
    下一层递归：i+1，cw,cp
```



### 3.3分支限界

分支限界和回溯算法最大的不同在于：

回溯是深搜的同时，将**每个结点的最好与整条线路的最好进行比较**，比较不成就不访问该子树。

分支限界则是宽搜，无法先找到整条线路的最好，因此只是将每层遍历到的活结点放入队列中，同时队列中的顺序按照每个结点的上限利润排序进行依次的输出。背包问题中选择的限界函数也就是它的利润。

```c++
//简略的伪代码如下
int (items, W)
    按照密度降序排列
    创建优先队列Q并在其中增加一个结点
    while !Q.empty()
        从 Q 中取出一个节点q
        if q在下一层
            if weight <= W 且profit > maxProfit
               maxProfitn = profit;
            if bound > maxProfit
                将节点添加到 Q
                
        if nextBound > maxProfit
            将节点添加到 Q
    return maxProfit
```



## 四：代码实现和实验结果

测试数据集：

第一行为物品数量n和总容量V，第2—n+1行分别为单件物品体积和价值。

示例1：

```matlab
10 165
23 92 
31 57
29 49
44 68
53 60
38 43
63 67
85 84
89 87
82 72
```

预期结果：

309

1111010000



示例2：

```matlab
7 170
41 442
50 525
49 511
59 593
55 546
57 564
60 617
```

  预期结果：

1735

0101001



示例3：

```matlab
15 750
 70 135
 73 139
 77 149
 80 150
 82 156
 87 163
 90 173
 94 184
 98 192
106 201
110 210
113 214
115 221
118 229
120 240
```

预期结果：

1458

101010111000011



### dp非递归（二维数组）

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1010;

int dp[MAXN][MAXN];
int choice[MAXN][MAXN], x[MAXN]; //存储物品状态
int N, V; //物品数量，总容量
int v[MAXN], w[MAXN]; //单件体积，单件价值

int main() {
	cin >> N >> V;
	for (int i = 1; i <= N; i++) {
		cin >> v[i] >> w[i];
	}

	for (int i = 1; i <= N; i++) {
		for (int j = 1; j <= V; j++) {
			//状态转移方程
			if (j >= v[i] && dp[i - 1][j] < dp[i - 1][j - v[i]] + w[i]) {
				dp[i][j] = dp[i - 1][j - v[i]] + w[i];
				choice[i][j] = 1;
			} else {
				dp[i][j] = dp[i - 1][j];
				choice[i][j] = 0;
			}
		}
	}

	cout << dp[N][V] << endl;

	// 输出选择的物品
	vector<int> items;
	for (int i = N, j = V; i > 0; i--)
		if (choice[i][j] == 1) {
			x[i] = 1;
			j -= v[i];
		}

	// 输出物品的存放状态
	for (int i = 1; i <= N; i++)
		cout << x[i];
	cout << endl;

	return 0;
}
```



### dp非递归(一维数组)

滚动数组优化的思路和元组法类似。

```c++
#include<iostream>
using namespace std;
const int MAXN = 1010;
#include<algorithm>

int dp[MAXN];
int N, V; //物品数量，总容量
int v[MAXN], w[MAXN]; //单件体积，单件价值

int main() {
	cin >> N >> V;
	for (int i = 1; i <= N; i++) {
		cin >> v[i] >> w[i];
	}

	for (int i = 1; i <= N; i++) {
		for (int j = V; j >= 1; j--)
            //滚动数组优化的思路
			if (j >= v[i])dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
	}
	cout << dp[V] << endl;
	return 0;
}
```



### dp递归

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1010;

int dp[MAXN][MAXN];
int choice[MAXN][MAXN], x[MAXN];
int N, V; //物品数量，总容量
int v[MAXN], w[MAXN]; //单件体积，单件价值

int knapsack(int i, int j) {
	//递归出口
	if (i == 0 || j == 0)
		return 0;

	if (dp[i][j] != -1)
		return dp[i][j];

	//状态转移方程
	if (j < v[i]) {
		choice[i][j] = 0;
		return dp[i][j] = knapsack(i - 1, j);
	} else {
		int value1 = knapsack(i - 1, j);
		int value2 = w[i] + knapsack(i - 1, j - v[i]);
		if (value1 > value2) {
			choice[i][j] = 0;//记录状态
			return dp[i][j] = value1;
		} else {
			choice[i][j] = 1;//记录状态
			return dp[i][j] = value2;
		}
	}
}

int main() {
	cin >> N >> V;
	for (int i = 1; i <= N; i++) {
		cin >> v[i] >> w[i];
	}

	memset(dp, -1, sizeof(dp));//初始化

	cout << knapsack(N, V) << endl;

	// 输出选择的物品
	vector<int> items;
	for (int i = N, j = V; i > 0; i--)
		if (choice[i][j] == 1) {
			x[i] = 1;
			j -= v[i];
		}

	// 输出物品的存放状态
	for (int i = 1; i <= N; i++)
		cout << x[i];
	cout << endl;

	return 0;
}
```



### dp元组法

```c++
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1010;
int dp[MAXN];
int choice[MAXN][MAXN], x[MAXN];
int v[MAXN], w[MAXN];

int main() {
	int N, V;
	cin >> N >> V;
	for (int i = 1; i <= N; i++) {
		cin >> v[i] >> w[i];
	}

	for (int i = 1; i <= N; i++) {
		for (int j = V; j >= v[i]; j--) {
			//改变关键位置的数据
			if (dp[j] < dp[j - v[i]] + w[i]) {
				dp[j] = dp[j - v[i]] + w[i];
				choice[i][j] = 1;
			}
		}
	}

	cout << dp[V] << endl;

	// 输出选择的物品
	vector<int> items;
	for (int i = N, j = V; i > 0; i--)
		if (choice[i][j] == 1) {
			x[i] = 1;
			j -= v[i];
		}

	// 输出物品的存放状态
	for (int i = 1; i <= N; i++)
		cout << x[i];
	cout << endl;

	return 0;
}
```



### 回溯

```c++
#include<bits/stdc++.h>
using namespace std;

struct Item {
	int w;//重量
	int v;//价值
	double density;//密度
	int index;
};

//仿函数，按照密度从大到小排序
bool compare(Item a, Item b) {
	return a.density > b.density;
}

vector<int> bestItems; // 用于保存最佳物品组合的向量

int knapsack(vector<Item>& items, int c) {
	sort(items.begin(), items.end(), compare);

	int bestv = 0;
	vector<int> currentItems(items.size(), 0); // 用于保存当前物品组合的向量

	function<void(int, int, int)> backtrack = [&](int i, int cw, int cv) {
		//递归出口
		if (i >= (int)items.size()) {
			if (cv > bestv) {
				bestv = cv;
				bestItems = currentItems; // 当找到更好的解决方案时，更新最佳物品组合
			}
			return;
		}

		if (cw + items[i].w <= c) {
			currentItems[i] = items[i].index; // 添加当前物品到当前物品组合
			backtrack(i + 1, cw + items[i].w, cv + items[i].v);
		}

		if (cv + (c - cw) * items[i].density > bestv) {
		    currentItems.erase(remove(currentItems.begin(), currentItems.end(), items[i].index), currentItems.end());
			backtrack(i + 1, cw, cv);
		}
	};

	backtrack(0, 0, 0);
	return bestv;
}

int main() {
	vector<Item> items = {{23, 92, 92 / 23, 0}, {31, 57, 57 / 31, 1}, {29, 49, 49 / 29, 2}, {44, 68, 68 / 44, 3}, {53, 60, 60 / 23, 4}, {38, 43, 43 / 38, 5}, {63, 67, 67 / 63, 6}, {85, 84, 84 / 85, 7}, {89, 87, 87 / 89, 8}, {82, 72, 72 / 82, 9}};
	int c = 165;
	cout << knapsack(items, c) << endl;

	// 打印最佳物品组合
	for (int i = 0; i < (int)items.size(); i++)	{
		if (find(bestItems.begin(), bestItems.end(), i) != bestItems.end())
			cout << 1;
		else 
			cout << 0;
	}

	cout << endl;

	return 0;
}
```



### 分支界限

```c++
#include<bits/stdc++.h>
using namespace std;

struct Item {
	int w;//重量
	int v;//价值
	double density;//密度
	int index;
};

struct Node {
	int level;//
	int profit;//利润
	int w;//重量
	int bound;//上界
};

bool compare(Item a, Item b) {
	return a.density > b.density;
}

vector<int> bestItems(10, 0); // 用于保存最佳物品组合的向量
vector<int> currentItems(10, 0); // 用于保存当前物品组合的向量

//上限
int bound(Node u, int n, int W, vector<Item>& items) {
	if (u.w >= W) return 0;
	int profit_bound = u.profit;
	int j = u.level + 1;
	int cw = u.w;
	while ((j < n) && (cw + items[j].w <= W)) {
		cw += items[j].w;
		profit_bound += items[j].v;
		j++;
	}
	if (j < n) profit_bound += (W - cw) * items[j].v / items[j].w;
	return profit_bound;
}

int knapsack(vector<Item>& items, int W) {
	sort(items.begin(), items.end(), compare);
	int n = items.size();
	
	Node u, v;//初始节点
	u.level = -1;
	u.profit = u.w = 0;
	
	//优先队列，存放活结点
	priority_queue<Node, vector<Node>, function<bool(Node, Node)>> Q([](Node u, Node v) {
		return u.bound < v.bound;});
	Q.push(u);
	
	int bestp = 0;
    //每次循环是处理一个结点，而不是一层。
	while (!Q.empty()) {
		u = Q.top();
		Q.pop();
		
		if (u.level == -1) v.level = 0;
		if (u.level == n - 1) continue;
		
		//子树，广搜需要找数据    
		v.level = u.level + 1;
		//下一层子树
		v.w = u.w + items[v.level].w;
		v.profit = u.profit + items[v.level].v;
		
		currentItems[items[v.level].index] = 1; // 添加当前物品到当前物品组合
		
		//更新点
		if (v.w <= W && v.profit > bestp) {
			bestp = v.profit;
			bestItems = currentItems; // 当找到更好的解决方案时，更新最佳物品组合
		}
		
		v.bound = bound(v, n, W, items);
		if (v.bound > bestp)Q.push(v);
		
		v.w = u.w;
		v.profit = u.profit;
		v.bound = bound(v, n, W, items);
		if (v.bound > bestp)Q.push(v);
	}
	return bestp;
}

int main() {
	vector<Item> items = {{23, 92, 92 / 23, 0}, {31, 57, 57 / 31, 1}, {29, 49, 49 / 29, 2}, {44, 68, 68 / 44, 3}, {53, 60, 60 / 23, 4}, {38, 43, 43 / 38, 5}, {63, 67, 67 / 63, 6}, {85, 84, 84 / 85, 7}, {89, 87, 87 / 89, 8}, {82, 72, 72 / 82, 9}};
	int W = 165;
	cout << knapsack(items, W) << endl;
	
	// 打印最佳物品组合
	for (int i = 0; i < (int)items.size(); i++)	{
		cout << bestItems[i];
	}
	
	return 0;
}
```



## 五：三种算法的比较和总结

### 1. 动态规划（自底而上）：

- 时间复杂度：O(nV)，其中n是物品的数量，V是背包的容量。
- 空间复杂度：O(nV)/O(n)，需要一个二维数组来存储状态,可滚动数组降维。

特点：
- 动态规划利用数组保存了每个子问题的解，它每个子问题和大问题的关联相同，并且存在重复的子树时也能通过数组快速找到问题的解。相比搜索方法最大的优势在于提高了效率，将时间复杂度从指数级降成了多项式级别，但代价是数组保存其中的子问题而导致的内存占用过多，因此更适合解决问题规模小且需要高效率的情况。

### 2. 回溯法（递归）和分支定界法（减枝）：

特点：

- 比较两个搜索的方案。

  从空间上看，回溯法深搜，占用的内存空间复杂度大概在O(解空间的最大路径)，但是分支定界的占用的内存为O(解空间大小)。对于子集空间和排列空间，回溯法的空间复杂度均为O(n)，分支定界的空间复杂度分别为O(2^n)和O(n!)。

  从时间上看，回溯法在解决0-1背包问题时的时间复杂度是O(n*2^n)。分支定界法在解决0-1背包问题时的时间复杂度是O(n*2^n)。这是因为分支定界法使用了贪心策略和剪枝操作，可以有效地减少搜索的解空间，从而降低了时间复杂度。但是，这个时间复杂度是在最坏情况下的，实际上，分支定界法的效率通常会比这个时间复杂度要高。

  

- 搜索问题的解决思路和动态规划不同，搜索问题致力于在解空间中找到一个最好的解，而动态规划则是在找最优解的过程中巧妙的发现了子问题和大问题之间的关系，从而达到了优化，从性能上来说，dp是更好的。总和来讲，对于大规模问题，由于效率的原因选择dp更好，但是同时也要注意内存是否足够或者占用更多。

  回溯法和分支定界法的主要优点是它们可以在搜索过程中剪枝，从而减少搜索空间，提高效率。但是，它们的时间复杂度通常比动态规划高，特别是在最坏的情况下。

  此外，回溯法和分支定界法可能只能找到局部最优解，而不是全局最优解。动态规划可以确保找到全局最优解，而不是局部最优解。
