#  	Leetcode And 洛谷

## 2023-08-20—2023-09-10

### 1.[1388. 3n 块披萨](https://leetcode.cn/problems/pizza-with-3n-slices/)（DP）

**给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：**

- **你挑选 任意 一块披萨。**
- **Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。**
- **Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。**
- **重复上述过程直到没有披萨剩下。**

**每一块披萨的大小按顺时针方向由循环数组 `slices` 表示。**

**请你返回你可以获得的披萨大小总和的最大值。**

思路：猜测是不是选择循环数组中三个不相邻数字和的最大值，采用动态规划解决。

```c++
class Solution {
public:
    int dpcalculate(const vector<int>& slices){
        int N = slices.size(),n=(N+1)/3;
        vector<vector<int>> dp(N,vector<int>(n+1,INT_MIN));
        dp[0][0] = 0;
        dp[0][1] = slices[0];
        dp[1][0] = 0;
        dp[1][1] = max(slices[0],slices[1]);
        for(int i=2;i<N;i++){
            dp[i][0]=0;
            for(int j=1;j<=n;j++){
                dp[i][j]=max(dp[i-2][j-1]+slices[i],dp[i-1][j]);
            }
        }
        return dp[N-1][n];
    }
    int maxSizeSlices(vector<int>& slices) {
        vector<int> v1(slices.begin() + 1, slices.end());
        vector<int> v2(slices.begin(), slices.end() - 1);
        int ans1 = dpcalculate(v1);
        int ans2 = dpcalculate(v2);
        return max(ans1, ans2);
    }
};
```



### 2.[1444. 切披萨的方案数](https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/)（DP）

**给你一个 `rows x cols` 大小的矩形披萨和一个整数 `k` ，矩形包含两种字符： `'A'` （表示苹果）和 `'.'` （表示空白格子）。你需要切披萨 `k-1` 次，得到 `k` 块披萨并送给别人。**

**切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。**

**请你返回确保每一块披萨包含 至少 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。**

思路：披萨中的苹果需要预处理数据，然后也可以分解为多个子问题，故仍然可以采用动态规划解决。

```c++
class Solution {
public:
    int ways(vector<string>& pizza, int k) {
        //依旧是动态规划的思路，将问题分解为子问题从而得到最优解
        //同时包含重叠子问题和最优子结构
        //首先对题中所给数据进行预处理,类似于二维的前缀和
        int m=pizza.size(),n=pizza[0].size(),mod=1e9+7;//m是列数，n是行数
        vector<vector<int>> apples(m+1,vector<int>(n+1));
        vector<vector<vector<int>>> dp(k + 1, vector<vector<int>>(m + 1, vector<int>(n + 1)));
        for(int i=m-1;i>=0;i--){
            for(int j=n-1;j>=0;j--){
                apples[i][j]=apples[i][j+1]+apples[i+1][j]-apples[i+1][j+1]+(pizza[i][j]=='A');//前缀和
                dp[1][i][j]=apples[i][j]>0;
            }
        }

        //动态规划处理
        //从切2快到k快，自下而上
        for(int ki=2;ki<=k;ki++){
            //从开头到结尾，自上而下
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++){
                    // 水平方向切
                    for (int i2 = i + 1; i2 < m; i2++) {
                        if (apples[i][j] > apples[i2][j]) {
                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i2][j]) % mod;
                        }
                    }
                    // 垂直方向切
                    for (int j2 = j + 1; j2 < n; j2++) {
                        if (apples[i][j] > apples[i][j2]) {
                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i][j2]) % mod; 
                        }
                    }
                }
            }
        }
        return dp[k][0][0];
    }
};
```



### 3.[2235. 两整数相加](https://leetcode.cn/problems/add-two-integers/)（高精度加法）

给你两个整数 `num1` 和 `num2`，返回这两个整数的和。

```c++
return num1+num2;
```



### 4.[2236. 判断根结点是否等于子结点之和](https://leetcode.cn/problems/root-equals-sum-of-children/)

给你一个 **二叉树** 的根结点 `root`，该二叉树由恰好 `3` 个结点组成：根结点、左子结点和右子结点。

如果根结点值等于两个子结点值之和，返回 `true` ，否则返回 `false` 。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool checkTree(TreeNode* root) {
        return root->val == root->left->val + root->right->val;
    }
};
```



### 5.[2337. 移动片段得到字符串](https://leetcode.cn/problems/move-pieces-to-obtain-a-string/)（双指针）

**给你两个字符串 `start` 和 `target` ，长度均为 `n` 。每个字符串 仅 由字符 `'L'`、`'R'` 和 `'_'` 组成，其中：**

- **字符 `'L'` 和 `'R'` 表示片段，其中片段 `'L'` 只有在其左侧直接存在一个 空位 时才能向 左 移动，而片段 `'R'` 只有在其右侧直接存在一个 空位 时才能向 右 移动。**
- **字符 `'_'` 表示可以被 任意 `'L'` 或 `'R'` 片段占据的空位。**

**如果在移动字符串 `start` 中的片段任意次之后可以得到字符串 `target` ，返回 `true` ；否则，返回 `false` 。**

思路：1.start和target的‘L’‘R’个数相同

2。start的L在target的右边，start的R在target的左边。

```C++
//超时，不建议
class Solution {
public:
    bool canChange(string start, string target) {
    //比较字符串大小，串1和串2中L和R的数量
	int sl=0,sr=0;
	for(int i=0;i<(int)start.size();i++){
		if(start[i]=='L')sl++;
		if(start[i]=='R')sr++;
	}
	int tl=0,tr=0;
	for(int i=0;i<(int)target.size();i++){
		if(target[i]=='L')tl++;
		if(target[i]=='R')tr++;
	}
	if(tl!=sl||tr!=sr)return false;
	
	//比较位置
	bool res=1;
	for(int i=0,j=0;i<(int)start.size();){
		if(start[i]=='_')i++;
		if(target[j]=='_')j++;
		if(start[i]=='L'&&target[j]=='L')if(j>i)res=0;
	}
	
	for(int i=start.size()-1,j=target.size()-1;i>=0;){
		if(start[i]=='_')i--;
		if(target[j]=='_')j--;
		if(start[i]=='R'&&target[j]=='R')if(j<i)res=0;
	}
	return res;
	
	}
};
```



```c++
//双指针优化
class Solution {
public:
    bool canChange(string start, string target) {
	int i = 0, j = 0;
	int n = start.size();
	while (i < (int)start.size() || j < (int)target.size()) {
		while (i < n && start[i] == '_')i++;
		while (j < n && target[j] == '_')j++;
		if (start[i] != target[j])return false;
		else if (start[i] == 'L' && i < j) return false;
		else if (start[i] == 'R' && i > j) return false;
		start[i] = target[j] = '_';
	}

	return true;
};
```



### 6.[849. 到最近的人的最大距离](https://leetcode.cn/problems/maximize-distance-to-closest-person/)(双指针+贪心)

**给你一个数组 `seats` 表示一排座位，其中 `seats[i] = 1` 代表有人坐在第 `i` 个座位上，`seats[i] = 0` 代表座位 `i` 上是空的（下标从 0 开始）。**

**至少有一个空座位，且至少有一人已经坐在座位上。**

**亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。**

**返回他到离他最近的人的最大距离。**

```c++
//思路一：找到两个有位置之间的最大距离（考虑只有一个位置和有两个及两个以上位置的情况）
class Solution {
public:
    int maxDistToClosest(vector<int>& seats) {
	int j = 0, dis = 0, maxdis = 0, n = seats.size() - 1;
	for (int i = 0; i <= n; i++) {
        //位置上有人时
		if (seats[i] == 1) {
            //考虑第i个位置之前都没有人
			if (j == 0 && seats[j] == 0)dis = i - j;
			else dis = (i - j) / 2;
			j = i;
		}
        //考虑第j个位置之后都没有人
		if (i == n && seats[i] == 0)dis = i - j;
        //找到最大距离
		if (maxdis < dis)maxdis = dis;
	}
	return maxdis;
}
};
```

```c++
//思路二：双指针+贪心
class Solution {
public:
    int maxDistToClosest(vector<int>& seats) {
        int res = 0;
        int l = 0;
        //找到第一个有人的座位并考虑这个座位之前都没有人的情况
        while (l < seats.size() && seats[l] == 0) {
            ++l;
        }
        res = max(res, l);
        //继续往后找
        while (l < seats.size()) {
            int r = l + 1;
            while (r < seats.size() && seats[r] == 0) {
                ++r;
            }
            //考虑到第l个座位到最后都没有人的局面
            if (r == seats.size()) {
                res = max(res, r - l - 1);
            } else {
                res = max(res, (r - l) / 2);
            }
            l = r;
        }
        return res;
    }
};
作者：力扣官方题解
链接：https://leetcode.cn/problems/maximize-distance-to-closest-person/solutions/2393766/dao-zui-jin-de-ren-de-zui-da-ju-chi-by-l-zboe/
来源：力扣（LeetCode）
```



### 7.[1782. 统计点对的数目](https://leetcode.cn/problems/count-pairs-of-nodes/)（二分查找）

**给你一个无向图，无向图由整数 `n` ，表示图中节点的数目，和 `edges` 组成，其中 `edges[i] = [ui, vi]` 表示 `ui` 和 `vi` 之间有一条无向边。同时给你一个代表查询的整数数组 `queries` 。**

**第 `j` 个查询的答案是满足如下条件的点对 `(a, b)` 的数目：**

- **`a < b`**
- **`cnt` 是与 `a` 或者 `b` 相连的边的数目，且 `cnt` 严格大于 `queries[j]` 。**

**请你返回一个数组 `answers` ，其中 `answers.length == queries.length` 且 `answers[j]` 是第 `j` 个查询的答案。**

**请注意，图中可能会有 重复边 。**



思路一：

统计整数1-n在edges中出现的次数，统计任意两个整数之间相连的边的个数，最终没结果为两个次数相加减去个数。这个是满足点对（a,b)的数目。再将所有数目放在一起，与queries比较，得出结果。

但是你的编程经验不足导致vector的二重用法不会，不能将思路完整实现。

```c++
//思路一：二分查找
class Solution {
public:
    vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {
        vector<int> degree(n);
        unordered_map<int, int> cnt;
        //degree指的是，某点的对应边数
        //同时用x*n+y记录xy之间的共同边数的个数
        for (auto edge : edges) {
            int x = edge[0] - 1, y = edge[1] - 1;
            if (x > y) {
                swap(x, y);
            }
            degree[x]++;
            degree[y]++;
            cnt[x * n + y]++;
        }
        
        //
        vector<int> arr = degree;
        vector<int> ans;
        sort(arr.begin(), arr.end());
        for (int bound : queries) {
            int total = 0;
            //利用二分查找在数组中查找当前度数大于 queries[i]−degree[a]的节点数量
            //先筛选出满足以上的要求的结点
            for (int i = 0; i < n; i++) {
                int j = upper_bound(arr.begin() + i + 1, arr.end(), bound - arr[i]) - arr.begin();
                total += n - j;
            }
            //从当点对 (a,b) 满足： degree[a]+degree[b]−cnt(a,b)≤queries[i]的记数减 1，最终得到的 total 即可本次的查询结果；
            //再通过有两点相连的进一步筛选，直接通过cnt筛选会漏掉两点不相连的可能
            //val是键值即x*n+y，freq是实值即（x，y）之间相连的边数
            for (auto &[val, freq] : cnt) {
                int x = val / n;
                int y = val % n;
                if (degree[x] + degree[y] > bound && degree[x] + degree[y] - freq <= bound) {
                    total--;
                }
            }
            ans.emplace_back(total);
        }

        return ans;
    }
};
。
```

```c++
//思路二：双指针
```



### 8.[1267. 统计参与通信的服务器](https://leetcode.cn/problems/count-servers-that-communicate/)（哈希表）

**这里有一幅服务器分布图，服务器的位置标识在 `m * n` 的整数矩阵网格 `grid` 中，1 表示单元格上有服务器，0 表示没有。**

**如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。**

**请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。**

```c++
//1.vector的两个row和col会报错，但是用map不会，map分为键值和实值
//2.在求值的时候等于1这个先决条件也要有
class Solution {
public:
    int countServers(vector<vector<int>>& grid) {
	//先保存每行每列的和
	unordered_map<int, int> row, col;

	int m=grid.size(),n=grid[0].size();
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			if(grid[i][j]==1){
				row[i]++;col[j]++;
			}
		}
	}

	//再求值
	int num=0;
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			if(grid[i][j]==1&&(row[i]>1||col[j]>1))num++;
		}
	}
	
	return num;
	}
};
```



### 9.[1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/)（递归）

**给你一棵根为 `root` 的二叉树，请你返回二叉树中好节点的数目。**

**「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。**

```c++
//注意：此为错误做法
//根本错误在于这个结点的值应该大于这条路上所有结点的值，而不能只考虑两到三层的值

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //用unordered_map去记错父母节点并且求是一个很好的思路
    unordered_map<TreeNode*, TreeNode*> parentMap;

// 在遍历的过程中记录节点的父节点信息
    //也采用了递归的思路
void buildParentMap(TreeNode* root) {
	if (!root) {
		return;
	}
	
	if (root->left) {
		parentMap[root->left] = root;
		buildParentMap(root->left);
	}
	if (root->right) {
		parentMap[root->right] = root;
		buildParentMap(root->right);
	}
}

TreeNode* findParent(TreeNode* node) {
	if (node == nullptr) {
		return nullptr;
	}
	
	return parentMap[node];
}

//
int goodNodes(TreeNode* root) {
	int res = 1;
	TreeNode *p = root;
	stack<TreeNode*> s;

	while (!s.empty() || p != NULL) {
		while (p != NULL) {
			s.push(p);
			if(p->left!=nullptr&&findParent(p)!=nullptr){
		  	if ((p->val <= p->left->val)&&(p->left->val>=findParent(p)->val))res++;
			}
			if(p->left!=nullptr&&findParent(p)==nullptr){
				if(p->left->val>=p->val)res++;
			}
			p = p->left;
		}

		if (!s.empty()) {
			p = s.top();
			s.pop();
			if(p->right!=nullptr&&findParent(p)!=nullptr){
		  	if ((p->val <= p->right->val)&&((p->right->val>=findParent(p)->val)))res++;
			}
			if(p->right!=nullptr&&findParent(p)==nullptr){
				if(p->right->val>=p->val)res++;
			}
			p = p->right;
		}
	}
	return res;
}
};
```



```c++
//官方题解
class Solution {
public:
    int dfs(TreeNode*root,int path_max)
{
	//先考虑结点为0的情况
	if(root==nullptr){
		return 0;
	}
	
	//要考虑本质上无论是左节点还是右节点
	//都要计算路径最大值并且作比较
	//递归出口在于root==nullptr
	int res = 0;
	if(root->val>=path_max){
		res++;
		path_max=root->val;//在判断的同时更新这条路径上的最大值
	}
	res+=dfs(root->left,path_max)+dfs(root->right,path_max);
	
	return res;
}

int goodNodes(TreeNode *root){
	return dfs(root,INT_MIN);
}

};
```



### 10.[228. 汇总区间](https://leetcode.cn/problems/summary-ranges/)（字符串）

**给定一个  无重复元素 的 有序 整数数组 `nums` 。**

**返回 *恰好覆盖数组中所有数字 的 最小有序 区间范围列表* 。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。**

**列表中的每个区间范围 `[a,b]` 应该按如下格式输出：**

- **`"a->b"` ，如果 `a != b`**
- **`"a"` ，如果 `a == b`**

```c++
vector<string> summaryRanges(vector<int>& nums) {
	vector<string> res;
	int num = nums.size();
	int i = 0;
	string s = "";
	while (i < num) {
		s = "";
		int l = i, r;
		while (i < num && nums[i] + 1 == nums[i + 1])i++;
		r = i;
		s += to_string(l);
		if (l != r) {
			s.append("->");
			s.append(to_string(r));
		}
		res.push_back(s);
	}

	return res;
}
```

```c++
//官方题解
class Solution {
public:
   vector<string> summaryRanges(vector<int>& nums) {
        vector<string> ret;
        int i = 0;
        int n = nums.size();
        while (i < n) {
            int low = i;
            i++;
            while (i < n && nums[i] == nums[i - 1] + 1) {
                i++;
            }
            int high = i - 1;
            string temp = to_string(nums[low]);
            if (low < high) {
                temp.append("->");
                temp.append(to_string(nums[high]));
            }
            ret.push_back(move(temp));
        }
        return ret;
    }

};
```



### 11.[56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

**以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。**

```c++
//错误解法分析
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
	vector<vector<int>> result;

	//排序
	sort(intervals.begin(), intervals.end());

	//
	int l = intervals[0][0];
    int r = intervals[0][1];
    int n = intervals.size();
    int m=r;
    //当intervals只有一组数时，直接返回
    if(n==1){
        result.push_back({l,r});
        return result;
    }
    //没有循环的意识，只针对单独的一种或者几种情况   
    int flag = 0;
	for (int i = 1; i < n; i++) {
        if (result.size()!=0 && result.back()[1]>intervals[i-1][0])break;

        if(flag==1){
            l = intervals[i-1][0];
            r = intervals[i-1][1];
        }
        
        //将前一组的第二个数和后一组的第一个数比较
		if (intervals[i-1][1] >= intervals[i][0]) 
        {
            //比较成功取二者右边较大的数
			r = max(r, intervals[i][1]);
            l = min(l, intervals[i][0]);
            //n-1的情况需要单独考虑
            if(i==n-1)result.push_back({l,r});
		}
        else 
        {
            //否则可以直接返回l和r的值
                result.push_back({l, r});
            
            //n-1的情况需要单独考虑
            if(i == n-1)result.push_back({intervals[n-1][0],intervals[n-1][1]});
            flag=1;
	    }
        
    }
    return result;
}
};

//问题在于你即使判断了一个两个或者一组，但是当后面一组小于前面一组的时候还是无法确认
```



```c++
//官方题解
vector<vector<int>> merge(vector<vector<int>>& intervals) {
	if (intervals.size() == 0) {
		return {};
	}
	sort(intervals.begin(), intervals.end());

	vector<vector<int>> merged;
	for (int i = 0; i < intervals.size(); ++i) {
		int L = intervals[i][0], R = intervals[i][1];
		if (!merged.size() || merged.back()[1] < L) {
			merged.push_back({L, R});
		} else {
			merged.back()[1] = max(merged.back()[1], R);
		}
	}
	return merged;
}
```

### 12.[57. 插入区间](https://leetcode.cn/problems/insert-interval/)

**给你一个 无重叠的 *，*按照区间起始端点排序的区间列表。**

**在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。**

```c++
//错误解法
vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
	vector<vector<int>> res;
	int m = intervals.size();
	int flag = 0;
	int l, r;

	if (!intervals.size()) {
		res.push_back(newInterval);
		return res;
	}

	if (newInterval[1] < intervals[0][0]) {
		res.push_back(newInterval);
		for (auto interval : intervals)res.push_back(interval);
		return res;
	}

	for (int i = 0; i < m; i++) {
		if (flag == 0) {
			if (intervals[i][1] < newInterval[0]) {
				res.push_back({intervals[i][0], intervals[i][1]});
			} else {
				l = min(intervals[i][0], newInterval[0]);
				r = max(intervals[i][1], newInterval[1]);
				flag = 1;
				if (i == m - 1)res.push_back({l, r});
			}
		}

		if (flag == 1) {
			if (newInterval[1] < intervals[i][0]) {
				res.push_back({l, r});
				if (i == m - 1)res.push_back({intervals[i][0], intervals[i][1]});
				flag = 0;
			} else {
				r = max(r, intervals[i][1]);
				l = min(l, intervals[i][0]);
			}
		}
	}
	if (newInterval[0] > intervals[m - 1][1])res.push_back(newInterval);
	return res;
}
```

```c++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        int left = newInterval[0];
        int right = newInterval[1];
        bool placed = false;
        vector<vector<int>> ans;
        for (const auto& interval: intervals) {
            if (interval[0] > right) {
                // 在插入区间的右侧且无交集
                if (!placed) {
                    ans.push_back({left, right});
                    placed = true;                    
                }
                ans.push_back(interval);
            }
            else if (interval[1] < left) {
                // 在插入区间的左侧且无交集
                ans.push_back(interval);
            }
            else {
                // 与插入区间有交集，计算它们的并集
                left = min(left, interval[0]);
                right = max(right, interval[1]);
            }
        }
        if (!placed) {
            ans.push_back({left, right});
        }
        return ans;
    }
};
```

### 13.[823. 带因子的二叉树](https://leetcode.cn/problems/binary-trees-with-factors/)

**给出一个含有不重复整数元素的数组 `arr` ，每个整数 `arr[i]` 均大于 1。**

**用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。**

**满足条件的二叉树一共有多少个？答案可能很大，返回 对 `109 + 7` 取余 的结果。**

```c++
class Solution {
public:
    int numFactoredBinaryTrees(vector<int>& arr) {
        sort(arr.begin(), arr.end());
        int n = arr.size();
        vector<long long> dp(n);
        long long res = 0, mod = 1e9 + 7;
        for (int i = 0; i < n; i++) {
            dp[i] = 1;
            for (int left = 0, right = i - 1; left <= right; left++) {
                while (right >= left && (long long)arr[left] * arr[right] > arr[i]) {
                    right--;
                }
                if (right >= left && (long long)arr[left] * arr[right] == arr[i]) {
                    if (right != left) {
                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod;
                    } else {
                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod;
                    }
                }
            }
            res = (res + dp[i]) % mod;
        }
        return res;
    }
};
```



### 14.[1654. 到家的最少跳跃次数](https://leetcode.cn/problems/minimum-jumps-to-reach-home/)

**有一只跳蚤的家在数轴上的位置 `x` 处。请你帮助它从位置 `0` 出发，到达它的家。**

**跳蚤跳跃的规则如下：**

- **它可以 往前 跳恰好 `a` 个位置（即往右跳）。**
- **它可以 往后 跳恰好 `b` 个位置（即往左跳）。**
- **它不能 连续 往后跳 `2` 次。**
- **它不能跳到任何 `forbidden` 数组中的位置。**

**跳蚤可以往前跳 超过 它的家的位置，但是它 不能跳到负整数 的位置。**

**给你一个整数数组 `forbidden` ，其中 `forbidden[i]` 是跳蚤不能跳到的位置，同时给你整数 `a`， `b` 和 `x` ，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达 `x` 的可行方案，请你返回 `-1` 。**

```c++
class Solution {
public:
    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {
        // 最远距离 bound = max(F + a + b, x + b)
        int F = *max_element(forbidden.begin(), forbidden.end()), bound = max(F + a + b, x + b);

        int ban[bound + 1];
        memset(ban, 0, sizeof(ban));
        for(int f : forbidden) {
            ban[f] = 1;
        }

        int dist[bound + 1][2]; // dist[i][0] - 上一次前跳, dist[i][1] - 上一次后跳
        memset(dist, 0x3f, sizeof(dist));
        dist[0][0] = 0;
        queue<pair<int,int>> q({{0, 0}});
        while(q.size()) {
            auto [i, pre] = q.front(); q.pop();
            if(i == x) {
                return dist[i][pre];
            }
            if(pre == 0 && i-b >= 0 && !ban[i-b] && dist[i][pre] + 1 < dist[i-b][1]) {
                dist[i-b][1] = dist[i][pre] + 1;
                q.emplace(i-b, 1);
            }
            if(i+a <= bound && !ban[i+a] && dist[i][pre] + 1 < dist[i+a][0]) {
                dist[i+a][0] = dist[i][pre] + 1;
                q.emplace(i+a, 0);
            }
        }

        return -1;
    }
};
```



### 15.[1761. 一个图中连通三元组的最小度数](https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/)

**给你一个无向图，整数 `n` 表示图中节点的数目，`edges` 数组表示图中的边，其中 `edges[i] = [ui, vi]` ，表示 `ui` 和 `vi` 之间有一条无向边。**

**一个 连通三元组 指的是 三个 节点组成的集合且这三个点之间 两两 有边。**

**连通三元组的度数 是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。**

**请你返回所有连通三元组中度数的 最小值 ，如果图中没有连通三元组，那么返回 `-1` 。**

```c++
class Solution {
public:
    int minTrioDegree(int n, vector<vector<int>>& edges) {
	int res = INT_MAX;
	vector<vector<int>> matrix(n, vector<int>(n));
	vector<int> degree(n);
	for (auto edge : edges) {
		int x = edge[0] - 1, y = edge[1] - 1;
		matrix[x][y] = matrix[y][x] = 1;
		degree[x]++;
		degree[y]++;
	}

	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) {
			if (matrix[i][j] == 1) {
				for (int k = j + 1; k < n; k++) {
					if (matrix[j][k] == 1 && matrix[k][i] == 1)
						res = min(res, degree[i] + degree[j] + degree[k] - 6);
				}
			}
		}
	}
	return res == INT_MAX ? -1 : res;
}
};
```



### 16.[1. 两数之和](https://leetcode.cn/problems/two-sum/)

**给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和为目标值 *`target`* 的那 两个 整数，并返回它们的数组下标。**

**你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。**

**你可以按任意顺序返回答案。**

```c++
//暴力
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
	vector<int> res;
	int n=nums.size();
	for(int i=0;i<n;i++){
		for(int j=i+1;j<n;j++){
			if(nums[i]+nums[j]==target){
				res.push_back(i);
				res.push_back(j);
			}
		}
	}
return res;
}
};
```

```c++
//哈希表
lass Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
			unordered_map<int,int> hashtable;
			for(int i=0;i<nums.size();i++){
				auto it = hashtable.find(target-nums[i]);
				if(it != hashtable.end())
				return {it->second,i};
				hashtable[nums[i]]=i;
			}
			return {};
}
};
```



### 17.[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)(双指针)

**给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。**

**找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。**

**返回容器可以储存的最大水量。**

**说明：你不能倾斜容器。**

```c++
int maxArea(vector<int>& height) {
	int l = 0, r = height.size() - 1;
	int res = 0;
	while (l < r) {
		int area = min(height[l], height[r]) * (r - l);
		res = max(area, res);
		//不管移动左边还是右边本质都是移动一个单位
		//所以移动高度高的一边
		if (height[l] <= height[r])
			l++;
		else r--;
	}
	return res;
}
```



### 18.[2240. 买钢笔和铅笔的方案数](https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils/)

**给你一个整数 `total` ，表示你拥有的总钱数。同时给你两个整数 `cost1` 和 `cost2` ，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。**

**请你返回购买钢笔和铅笔的 不同方案数目 **。

```c++
class Solution {
public:
    long long waysToBuyPensPencils(int total, int cost1, int cost2) {
	long long res=0,ans=0,c1=total/cost1,c2=0;
	for(int i=0;i<=c1;i++){
		ans=total-cost1*i;
		res=res+ans/cost2+1;
	}
	return res;
}
};
```



### 19.[2511. 最多可以摧毁的敌人城堡数目](https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/)

**给你一个长度为 `n` ，下标从 0 开始的整数数组 `forts` ，表示一些城堡。`forts[i]` 可以是 `-1` ，`0` 或者 `1` ，其中：**

- **`-1` 表示第 `i` 个位置 没有 城堡。**
- **`0` 表示第 `i` 个位置有一个 敌人 的城堡。**
- **`1` 表示第 `i` 个位置有一个你控制的城堡。**

**现在，你需要决定，将你的军队从某个你控制的城堡位置 `i` 移动到一个空的位置 `j` ，满足：**

- **`0 <= i, j <= n - 1`**
- **军队经过的位置 只有 敌人的城堡。正式的，对于所有 `min(i,j) < k < max(i,j)` 的 `k` ，都满足 `forts[k] == 0` 。**

**当军队移动时，所有途中经过的敌人城堡都会被 摧毁 。**

**请你返回 最多 可以摧毁的敌人城堡数目。如果 无法 移动你的军队，或者没有你控制的城堡，请返回 `0` 。**

****

```C++
//经典超时
int captureForts(vector<int>& forts) {
	int count(int i, int j, int x) ;
	int ans = 0;

	if (find(forts.begin(), forts.end(), 1) == forts.end() || find(forts.begin(), forts.end(), -1) == forts.end()) {
		return 0;
	}

	int n = forts.size();
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (i > j)swap(i, j);
			if (forts[i]*forts[j] == -1) {
				int res = 0;
				for (; i <= j; i++) {
					if (forts[i] == 0)res++;
				}
				ans = max(ans, res);
			}
		}
	}
	return ans;

}
```

```c++
int captureForts(vector<int>& forts) {
	int ans = 0, pre = -1;//pre类似与哨兵的作用
	for (int i = 0; i < forts.size(); i++) {
		if (forts[i] == 1 || forts[i] == -1) {
			if (pre >= 0 && forts[i] != forts[pre]) {
				ans = max(ans, i - pre - 1);
			}
			//i和pre分别记录两次的值
			pre = i;
		}
	}
	return ans;
}
```



20.[1921. 消灭怪物的最大数量](https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/)

**你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 下标从 0 开始 且长度为 `n` 的整数数组 `dist` ，其中 `dist[i]` 是第 `i` 个怪物与城市的 初始距离（单位：米）。**

**怪物以 恒定 的速度走向城市。给你一个长度为 `n` 的整数数组 `speed` 表示每个怪物的速度，其中 `speed[i]` 是第 `i` 个怪物的速度（单位：米/分）。**

**怪物从 第 0 分钟 时开始移动。你有一把武器，并可以 选择 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。**

**一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 恰 在某一分钟开始时到达城市，这会被视为 输掉 游戏，在你可以使用武器之前，游戏就会结束。**

**返回在你输掉游戏前可以消灭的怪物的 最大 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回 `n` 。**

```c++
class Solution {
public:
    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {
	int n = dist.size();
	vector<int> res(n);//要多少次怪物到达城市，向上取整
	for (int i = 0; i < n; i++) {
		res[i] = (dist[i] + speed[i] - 1) / speed[i];
	}
	sort(res.begin(), res.end());

	for (int j = 0; j < n; j++) {
		//可以走的次数减去已经走的次数小于等于0则失败
		if (res[j] - j <= 0)return j;
	}
	return n;
}
};
```



### 20.[449. 序列化和反序列化二叉搜索树](https://leetcode.cn/problems/serialize-and-deserialize-bst/)

**序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。**

**设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
	public:
		string serialize(TreeNode* root) {
			string res;
			vector<int> arr;
			//后序遍历，得到数组arr
			postOrder(root, arr);
			if (arr.size() == 0) {
				return res;
			}

			//将数组转换为字符串
			for (int i = 0; i < arr.size() - 1; i++) {
				res.append(to_string(arr[i]) + ",");
			}
			//去掉最后一个符号
			res.append(to_string(arr.back()));
			return res;
		}

		vector<string> split(const string &str, char dec) {
			int pos = 0;
			int start = 0;
			vector<string> res;
			while (pos < str.size()) {
				//找到第一个不为字符的
				while (pos < str.size() && str[pos] == dec) {
					pos++;
				}
				start = pos;
				//找到不为字符之后的几个不为字符的字符
				//可能是n位数
				while (pos < str.size() && str[pos] != dec) {
					pos++;
				}
				//子串
				if (start < str.size()) {
					//start开始的几个字符
					res.emplace_back(str.substr(start, pos - start));
				}
			}
			return res;
		}

		TreeNode* deserialize(string data) {
			if (data.size() == 0) {
				return nullptr;
			}

			//去除所有的“，”
			vector<string> arr = split(data, ',');
			stack<int> st;
			for (auto & str : arr) {
				//将字符转换为整数
				st.emplace(stoi(str));
			}
			// construct()是一种函数模板，用于在已分配的内存空间上构造一个对象，它是C++标准库中的一部分。
			return construct(INT_MIN, INT_MAX, st);
		}

		//后序遍历
		void postOrder(TreeNode *root, vector<int> & arr) {
			if (root == nullptr) {
				return;
			}
			postOrder(root->left, arr);
			postOrder(root->right, arr);
			arr.emplace_back(root->val);
		}

		//构造的函数
		//后序遍历的递归
		TreeNode * construct(int lower, int upper, stack<int> & st) {
			if (st.size() == 0 || st.top() < lower || st.top() > upper) {
				return nullptr;
			}
			int val = st.top();
			st.pop();
			TreeNode *root = new TreeNode(val);
			root->right = construct(val, upper, st);
			root->left = construct(lower, val, st);
			return root;
		}
};

// Your Codec object will be instantiated and called as such:
// Codec* ser = new Codec();
// Codec* deser = new Codec();
// string tree = ser->serialize(root);
// TreeNode* ans = deser->deserialize(tree);
// return ans;

```



### 21.[2605. 从两个数字数组里生成最小数字](https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/)(空间换时间)

**给你两个只包含 1 到 9 之间数字的数组 `nums1` 和 `nums2` ，每个数组中的元素 互不相同 ，请你返回 最小 的数字，两个数组都 至少 包含这个数字的某个数位。**

```c++
class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
	//1.判断数组中有没有相同元素
	//2.找出数组中的最小元素
 int arr[10]={0};

	sort(nums1.begin(),nums1.end());
	sort(nums2.begin(),nums2.end());
	
	int ans=0;
	for(int i=0;i<nums1.size();i++){
		arr[nums1[i]]=1;
	}

	for(int j=0;j<nums2.size();j++){
		if(arr[nums2[j]]==1){
			ans=nums2[j];
			break;
		}
	}

	if(ans!=0)return ans;

	if(nums1[0]>nums2[0])ans=nums2[0]*10+nums1[0];
	else ans=nums1[0]*10+nums2[0];
	return ans;
}
};
```

