近期看到两道挺相似的题目。相似点在于：1都是将一个字符串经过一系列操作变为另一个字符串，问操作数。2都是动态规划的解法。

#### 题一：[902. 最短编辑距离 - AcWing题库](https://www.acwing.com/problem/content/description/904/)

> 给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：
>
> 1. 删除–将字符串A中的某个字符删除。
> 2. 插入–在字符串A的某个位置插入某个字符。
> 3. 替换–将字符串A中的某个字符替换为另一个字符。
>
> 现在请你求出，将A变为B至少需要进行多少次操作。



```c++
#include<iostream>
using namespace std;
const int N = 1005;

int dp[N][N];
int n, m;
char a[N], b[N];

int main() {
	cin >> n >> (a + 1) >> m >> (b + 1);
    //这个前置处理分别代表了插入和替换过程中变换字符的最小次数
	for (int i = 1; i <= n; i++)dp[i][0] = i;
	for (int j = 1; j <= m; j++)dp[0][j] = j;

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (a[i] == b[j])dp[i][j] = dp[i - 1][j - 1];
			else dp[i][j] = 1 + min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]);//同时包括删除，插入和替换
		}
	}

	cout << dp[n][m] << endl;

	return 0;
}
```



#### 题二：[2896. 执行操作使两个字符串相等 - 力扣（LeetCode）](https://leetcode.cn/problems/apply-operations-to-make-two-strings-equal/description/)

> 给你两个下标从0开始的二进制字符串 `s1` 和 `s2` ，两个字符串的长度都是 `n` ，再给你一个正整数 `x` 。
>
> 你可以对字符串 `s1` 执行以下操作 **任意次** ：
>
> - 选择两个下标 `i` 和 `j` ，将 `s1[i]` 和 `s1[j]` 都反转，操作的代价为 `x` 。
> - 选择满足 `i < n - 1` 的下标 `i` ，反转 `s1[i]` 和 `s1[i + 1]` ，操作的代价为 `1` 。
>
> 请你返回使字符串 `s1` 和 `s2` 相等的 **最小** 操作代价之和，如果无法让二者相等，返回 `-1` 。
>
> **注意** ，反转字符的意思是将 `0` 变成 `1` ，或者 `1` 变成 `0` 。

这个题和上面不同的在于对第一个字符串的操作，第一个能够使用的三种操作无非是增加，删除，变换，都是对一个字符的操作。

但是这个题目中的操作是对两个字符变动，所以式子不太好找。