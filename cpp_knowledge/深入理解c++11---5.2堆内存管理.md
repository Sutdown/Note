### C++11：堆内存管理 智能指针和垃圾回收



参考书籍：

《深入理解C++11：C++11新特性解析与应用》



正文：

当写程序时，如果出现程序运行时突然退出，占用内存越来越多最后不得不重启的一些典型症状，有一定概率时C++中的**显式堆内存管理**并不完善，指针的自由度极高，对程序员的要求也更高。

从语言层面可以归结以下几个问题：

- **野指针**：内存单元已经释放但是指针还在使用，当该内存重新被分配时，容易出现不可预测的错误。
- **重复释放**：程序试图释放已经释放过的内存，或者释放已经被重新分配过的内存单元，就会出现重复释放错误。通常重复释放内存会导致C/C++运行时系统打印出大量错误和诊断信息。
- **内存泄露：**不需要使用的内存单元没有被释放同样会造成内存谢罗。



为了更好的进行内存管理，c++提出了**智能指针和垃圾回收**的概念，但是直到c++11都还存在着完善空间。

C++98中，采用模板类型`auto_ptr`实现。

C++11中，采用`unique_ptr`，`shared_ptr`，`weak_ptr`实现。weak_ptr的出现很大程度是对于shared_ptr的环形操作进行处理的。

- **unique_ptr**：与所指对象的内存紧密绑定，删除了拷贝构造函数，但是保留了移动构造函数。移动构造可以结合move转移对象内存的所有权，原对象会失效。
- **shared_ptr**：允许多个智能指针共享的拥有同一个堆分配对象的内存，实现上增加引用计数，只有当引用计数为0时才会释放内存。
- **weak_ptr**：它可以指向Shared_ptr指向的对象内存，但是并不拥有该内存，而使用weak_ptr的成员lock，就可以返回指向内存的一个shared_ptr对象，并且在所指对象内存无效时，会返回指针空值。



而对于不再使用或者没有任何指针指向的内存空间称为**垃圾**，对于这些垃圾收集起来再次利用的机制称为**垃圾回收**。

主要分为两大类：

1. **基于引用计数的垃圾回收器**

   **reference counting garbage collector**

   采用引用计数，当计数变为0时可以回收，不会堆系统缓存或者交换空间存在冲击，实现简单，但是额外开销不小，也很难处理**环形引用**问题。

2. **基于跟踪处理的垃圾回收器**

   **tracing garbage collector**

   - **标记-清除（Mark-Sweep）**：根据正在使用的对象进行查找，标记正在使用的内存，有标记的就是可达对象或者或对象，没有标记的就是垃圾，会被清扫掉。

     特点：活得对象不会移动，但是存在内存碎片。

   - **标记-整理（Mark-Compact）**

     和上一种基本相同，区别在于会将活对象向左靠齐，但是容易出现大量的内存碎片

     特点：移动活的对象，但是程序中所有对堆内存的引用都需要更新。

   - **标记-拷贝（Mark-Copy）**

     From分配满的时候开始垃圾回收，从From堆空间找出所有活的对象，拷贝到To的堆空间里，交换form和to的角色，重新分配。

     堆的利用率只有一半，而且也需要移动活的对象。



因此，C++11中提出了**最小垃圾支持**的概念。

首先指定了一个**安全派生(safely derived)的指针**的概念。安全派生的指针是指向由new分配的对象或者子对象的指针。安全派生指针的操作包括：

- 在解引用基础上的引用。比如&*p
- 定义明确的指针操作。比如p+1
- 定义明确的指针转换。比如static_cast<void*>(p)
- 指针和整型之间的reinterpret_case。比如reinterpret_cast<intptr_t>p

在c++11的规则中，最小垃圾回收是基于安全派生这个概念的。

程序员可以通过**get_pointer_safety()**函数查询确认编译器是否支持这个特性：

- pointer_safety::strict：表明编译器支持最小垃圾回收以及安全派生相关概念。
- pointer_safety::relax或者pointer_safety::preferred，则表明编译器不支持垃圾回收。



此外，C++11允许程序员通过一些API通知垃圾回收器不得回收该内存。

比如`declare_reachable(void *p)`函数和`undeclare_reachable<class T> T *undeclare_reachable(T *p) noexcept`；

`void declare_no_pointers(char* p, size_t n) noexcept;`和`void undeclare_no_pointers(char* p, size_t n) noexcept;`