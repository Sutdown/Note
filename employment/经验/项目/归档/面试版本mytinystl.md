## Mytinystl

> 之前的文章末尾写过一些总结性的，大部分面试官应该会就着container的底层原理问，allocator和iterator应该也会问问，大概率不深究吧。要深究的话就是container的细节或者手写，allocator和iterator会问到源码这样子，猜的。。还没面过，面过有问再改了。
>
> 这部分好像学的还行，大部分都挺清晰的居然没忘（），对我而言最大的难点在于iterator, rbtree和hashtable三部分了，再重点瞧瞧。
>
> 2024.9.24
>
> ------------------------------------------------------------------------
>
> 虚假的，更新1
>
> 里面其实涉及了很多c++11的新特性，但是我对c++11的新特性了解实在微弱，所以看这份源码的时候属实算不上扎实，特此更新部分内容。
>
> 2024.10.14

## allocator.h

**使用方法：**

- 重载和SFINAE使得在stl中会选择合适的重载函数，即使选择失败了也不会报错而是会继续尝试其它函数。
- 采用可变模板参数的通用引用+forward或者右值引用+移动语义，减少了额外拷贝，节约资源提升性能。

**代码结构：**

allocate使用的是operator new，相对应的deallocate使用的是operator delete，对应的是空间的分配和释放。

construct和destory在非平凡析构函数的是显式调用构造和析构函数，对于平凡析构函数，函数内部会自行调用构造和析构函数，用于对象的构造和析构

> Q：代码中还存在aloc.h中利用内存池和自由链表的另一种方式，如今已经被弃用，主要原因在于glibc的malloc/free的内存池设计已经实现的极为精巧，充分利用了是恐惧不行在内存管理和内存消耗的取舍，请详细介绍下两者的对比。

A：

这个文章里面好像写了，本身内存池和自由链表的创造是为了增加性能的，防止malloc时过多的内存碎片导致的内存泄露，但是随着后来malloc机制的逐渐优化，这种思路就被弃用了。

glibc中的内存池代码分析链接：[glibc malloc源码分析](https://chenyuzhuwhiskey.github.io/glibc-malloc-analysis/)





## iterator.h

> Q：iterator中有些模板元编程或者type_traits或者一些不太熟悉的特性，请介绍iterator的实现思路并且重点讲讲这些特性的使用和好处。

A：

**结构：**

iterator可以从五个内嵌相应型别入手，迭代器类别，值类型，指针，引用，距离范围。

**迭代器类别**有五个，输入，输出，前向，双向，随机存取

针对有没有迭代器，是什么迭代器，利用重载，偏特化和SFINA技术用于判断迭代器的种类。
对于**原生指针，常量指针，类指针**都会有对应的偏特化版本。
同样也有前进和后退的重载，引用和指针的重载等等，主要是采用类型萃取以便于在编译器确立类型。具体不同容器对于迭代器不同的使用在容器的代码中会详细说明。





> Q：容器中有几个最为底层的，比如vector,list,RBtree,hashable，这些都是heap，priority_queue，set，map等实现的基础，这些也成为container adapter，请介绍这些最为底层的容器。

A：

一般容器中分为迭代器和容器的基本函数实现两部分。

## **vector**

> 由于vector时采用连续的内存空间，因此迭代器很类似于普通的常量指针
> 对于一些基础的迭代器时采用对于vector结构中的私有成员begin,end,cur指针的直接调用进行的。
> 基础函数的话就比如构造，析构，push，pop，erase，clear，insert在文章中都有过程的阐述。
> 欸对，还有push和emplace一般来说emplace会利用右值引用和完美转发所以性能更好。
> 构造析构其实都是allocate，deallocate，construct，destory函数的调用之类的。后面的基础函数也同样。和我们之前了解的vector的底层思想一致。
> 比如空间不够，了重新拿个空间重新分配，设置成两倍一点五倍；push时会判断有没有备用空间要不要重新分配；pop时直接destory，erase本质上是将后面元素整体向前移动，时间复杂度O(n)，在destory多余的部分；clear就是erase所有；insert同样是需要分配有无备用空间，有备用空间怎么移动之类的，详细看文章或者去看源码了。





## **list**

> 迭代器的主要作用是遍历，访问和操作链表中的元素，在list中会重载解引用，自增自减之类的运算符，一般都是直接调用比如node的prev，next指针或者节点的值。不过源码中同时重载了普通指针和常量指针，普通指针用于修改容器中存储的元素，常量指针表明支持list的只读操作。
> 后面的构造析构pushpopremove等也是对于算法的要求更多，然后涉及空间的分配，list中主要是节点的前后指针值和list中的尾指针和大小。



## **deque**

> 双端队列，这个就比以上两个都要更复杂了，这是一段虚假的连续空间，哪怕你迭代器加加减减的很顺利，其实都是无数行默默的代码换来的。
> deque的迭代器是会直接包含list的相关特性的，当然也重载了普通指针和常量指针，设置的成员数据有缓冲区当前元素，头部元素，尾部元素所在节点之类的，内部重载运算符，这个是一定要区分指针++或者--时还在不在当前缓冲区的。
> 至于deque本身那当然要充分符合它自身的特性，私人成员有，指向第一个和最后一个节点，每块map以及map的大小，然后基本函数中要注意缓冲区大小的设置，缓冲区边界，全部清空时记得保留一个缓冲区。



## **RBtree**

> 红黑树的迭代器提供了一种类似指针的方式来访问和遍历容器中的元素。其中也是直接包含红黑树的节点，红黑树的节点内部有父节点，左右子节点和它本身的值，红黑树本身则包括根节点（特殊节点），结点数，键值比较原则这些。迭代器则是要实现自增自减，还有插入删除时树涉及的旋转之类的，也要重载元素键值是否重复，每个节点的的键值和值之类的，这些都是为之后的set，map等提供基础。





## **hashable**

> 哈希表的主要优势应该是在于类似于数组的存取效果。不过当元素过于的散乱时数组显得太过于浪费空间，这也就是哈希表的阐述，哈希表一般会采用取模之类的在某个范围建立一个bucket，但是这样会发生哈希碰撞，然后相应的解决方式有线性探测，二次探测开链等。这里采用的是开链，也就是当重复时会直接在该位置建立链表。将键映射到bucket的索引。
> 同时哈希表会存在容量和负载因子，当负载因子(每个同的平均元素数量），当负载因子过高时链表变长查找效率下降便会自动调整容量，容量也是用某个数组自动由小到大存储。哈希表中的bucket_type对应的是vector<node_ptr>，而node_ptr中存储也是链表节点，后面的函数插入删除基本思路也就确定了。
>
> 感觉在这些容器中频繁使用的知识有，namespace（stl的源码都是在mystl中实现的），typedef为类型重新命名，typename声明其是类型，完美转发，重载，模板元编程等等。





## container adapter

> Q：这些container adapter其实大多都是重载一下运算符，然后缺省其中的一部分函数最终实现的，仅仅这么简单吗，有没有什么注意点？

A：

就感觉，，，没什么注意点吧。

设置一些相关型别，原生指针，常量指针，类指针

然后构造复制移动析构函数，迭代器的开始结束加加减减，

容器的容量，增删改查，特定容器接口的特定操作，

就直接继承底层容器的相关部分，然后不相干的封闭之类的。

