害，好好看看这部分，你的简历过了跟项目测试肯定有关系，这绝对是必问的。



### gtest



#### 基于`LSM`的`KV`存储引擎

`gtest`时google发布的单元测试框架

其中`Test(测试套件名称，测试名称){ EXPECT_EQ(a, b); }`


```latex
\datedsubsection{\textbf{基于LSM的KV存储引擎}}{2024.10 - 2024.11}
\textbf{项目背景：本项目主要参考Google开源项目levelDB，实现了一个基于LSM结构的键值存储引擎。}

\textbf{项目职责：}
\begin{itemize}
    \item {\textbf{内存管理}：设计内存池机制和分片LRU缓存系统，优化内存管理，支持多分片减少锁竞争，并通过回调函数实现缓存项淘汰时的资源清理。}
    \item {\textbf{SSTable设计}：设计SSTable文件格式，实现了数据块（Data Block）、索引块（Index Block）、元数据块（Meta Block）等的存储，并使用多级索引和布隆过滤器优化查询性能。}
    \item {\textbf{持久化}：实现了SkipList作为Memtable的数据结构，通过优化算法提高内存中的数据存取效率，支持基本的读写操作。}
    \item {\textbf{文件读写}：实现了高效的文件读写操作，优化了WAL和SSTable文件的持久化过程，同时支持并发读取。}
    \item {\textbf{数据库接口}：设计并实现了数据库的接口层，支持数据高效的Put，Delete，Get操作，完善整体逻辑。}
    \item {\textbf{日志系统}：使用单例模式设计日志系统，采用spdlog库实现高效的多线程日志记录，并确保日志实例的唯一性和高效性。}
\end{itemize}
\textbf{项目成果：}
项目中实现了日志、布隆过滤器、内存分配器、缓存管理、文件读写、SSTable存储、写前日志（WAL），MemTable管理等核心模块，对各模块进行了单元测试。用键值对存储，支持快速写入和高效查询，具备良好的稳定性和性能。
```

###### allocate

检查能否正确存储和修改数据；

能否正确分配和释放内存；

检查重新分配功能的正确性；

分配大规模的数据能否正确进行分配和释放。

###### bloom filter

随机插入数据，分别进行正确性测试（哈希函数，位数组设置，位数组大小）和假阳性测试(哈希函数个数，位数组大小，数据是否正确插入)

进行大规模测试

###### db

检查put实现（put状态），

检查get实现（得到数据和预期一致）；

###### `lru cache`

测试插入超过缓存容量时能否正确处理淘汰策略；

测试不同键存在或不存在常见下能否正确删除；

测试缓存中的值能否正确被取出；

测试一个综合场景

###### `memtable`

**插入新值** (`Insert__Add`):
这个测试用例创建一个 `MemTable` 对象，并插入 `1234` 条键值对。之后通过 `Get` 方法验证插入的键值对是否正确。

**插入重复值** (`Insert__add_update`):
该测试首先插入键值对，然后随机决定是否更新这个键的值，模拟重复值插入的情况，最后验证每次更新后 `Get` 方法的结果是否正确。

**插入并删除** (`Insert__Deletion`):
这个测试在每次插入键值对后，会随机决定是否删除该键，并验证删除后 `Get` 方法返回空字符串（表示键已被删除）。

**迭代器测试** (`MemTableIterator`):
该测试创建一个包含 `1000` 个键值对的 `MemTable`，然后使用 `MemTable` 提供的迭代器遍历所有的键值对，验证每个键值对是否与插入的匹配。

###### `skiplist`

**测试插入**：第一个测试检查向`skiplist`中插入两个键值对，验证插入过程是否没有错误。

**测试插入多个条目**：第二个测试向`skiplist`中插入100个条目，检查插入是否没有问题。

**测试`Contains`方法**：第三个测试验证`Contains`方法。在插入一些键值对后，检查`skiplist`是否能正确返回现有键的`true`和不存在的键的`false`。

**随机插入后的`Contains`测试**：第四个测试类似于第三个，但插入了随机数目和内容的键。测试了`Contains`方法在已有和不存在的键上的行为。

**测试删除**：第五个测试验证从`skiplist`中删除键后，`Contains`方法是否会返回`false`，确保删除操作生效。

**随机删除后的`Contains`测试**：第六个测试检查随机删除键的情况，确保`skiplist`正确地反映了已删除的键。

**测试`Get`方法**：第七个测试验证`Get`方法，确保它能正确获取现有键的值，并返回`std::nullopt`（表示不存在）对于不存在的键。

**随机删除后的`Get`测试**：与前面的`Get`测试类似，但这次删除操作是随机进行的。测试确保已删除的键返回`std::nullopt`，未删除的键返回正确的值。

**测试`GetSize`和`GetMemUsage`方法**：最后一个测试检查`GetSize`和`GetMemUsage`方法，确保skiplist在插入和删除元素时能够正确跟踪元素数量和内存使用情况。

###### 综合

1. **`GenerateRandomString`**：生成指定长度的随机字符串，用作数据库插入的值。

   - 它使用一个随机数生成器 `std::mt19937` 和一个均匀分布 `std::uniform_int_distribution` 来从字符集中随机选取字符。

2. **`BenchmarkDBInsertionAndRead`**：核心的压测函数。它执行两个操作：

   - **插入操作**：通过调用 `db.Put()` 方法将 100,000 条数据插入数据库。
   - **读取操作**：通过调用 `db.Get()` 方法读取这 100,000 条数据。

   在插入和读取过程中，分别使用 `std::chrono::high_resolution_clock` 来测量每个操作的持续时间。

   - **`db.Put()`**：插入一个键值对。
   - **`db.Get()`**：通过键读取对应的值。
   - **`lsmkv::DBStatus`**：用来检查操作是否成功。

3. **`main`**：程序的入口点，调用 `BenchmarkDBInsertionAndRead` 来执行性能测试，默认插入和读取 10 万条数据。

**测试的功能**

- **插入性能测试**：测试在数据库中插入大量数据的时间。
- **读取性能测试**：测试在数据库中读取大量数据的时间。

**性能测试的输出**

该程序会输出两条信息：

1. **插入数据所需的时间**：输出插入指定数量（100,000 条）数据所花费的时间。1-2分钟
2. **读取数据所需的时间**：输出读取指定数量（100,000 条）数据所花费的时间。4-5分钟



### C++服务器框架-`Coroutinelib`

```latex
\datedsubsection{\textbf{C++服务器框架-Coroutinelib}}{2024.11}
\textbf{项目背景：本项目主要参考开源项目sylar，实现了linux环境下使用C++从零开发的部分服务器框架—协程库。}

\textbf{项目职责：}
\begin{itemize}
    \item {\textbf{协程实现}：基于ucontext\_t实现了能够resume和yield的具有\textbf{独立栈}的非对称协程，同时设计三种协程状态，使子协程可以和线程主协程相互切换。}
    \item {\textbf{协程调度}：实现了了N-M协程调度器。采用线程池和协程任务队列维护了一个调度线程池，同时支持主协程参与调度。}
    \item {\textbf{定时器}：基于最小堆实现了定时器功能，设计Timer类和TimerManager类，支持定时事件的添加，删除，更新。}
    \item {\textbf{协程IO}：在基本的协程调度器基础上结合epoll机制，同时利用pipe，定时器详细对tickle和idle函数进行重载，实现完整的协程IO。}
    \item {\textbf{性能测试}：利用原生epoll和本项目分别编写单线程简易服务器，利用ApacheBench进行压力测试，request条数100000，并发连接数1000，RPS分别为1526.14，1490.21，同时修改request数量和并发连接，根据两者吞吐量，响应时间，稳定性等判断本项目性能良好。}
\end{itemize}
\textbf{项目成果：}
项目主要实现了协程库的编写，基于ucontext\_t实现了协程类，结合epoll和定时器实现了N-M协程调度器，支持IO事件，定时器事件的回调。通过减少上下文切换开销，优化了IO密集型任务的并发处理。
```

###### fiber

1. **协程创建与调度**： 确保调度器正确地创建了多个协程并添加到调度队列。每个协程任务应该与一个唯一的参数`i`相关联。
2. **协程执行**： 检查协程任务是否按顺序被执行，输出结果是否符合预期。每个协程应该输出`hello world i`，并且`i`的值应该从0到19。
3. **任务队列管理**： 确保任务队列在执行后被清空。通过`m_tasks.clear()`可以确保所有的任务执行完后，队列被正确清空。
4. **协程资源管理**： 使用`std::shared_ptr<Fiber>`来管理协程资源，确保协程在不再需要时能自动销毁，避免内存泄漏。
5. **边界条件**： 可以考虑进一步扩展，验证在没有任务的情况下调用`run()`，或者创建大量协程时调度器的行为。

总结起来，代码的测试思路主要集中在验证协程创建、调度和执行是否符合预期，确保调度器能够正确地管理协程任务，并且所有资源都能够被正确管理和释放。

###### `scheduler`

1. **验证任务调度**： 确保调度器能够成功调度任务，并且任务能够在多个线程之间并行执行。
2. **线程安全验证**： 使用 `mutex_cout` 确保输出不会发生竞态条件，验证每个任务的编号是否按顺序增加。
3. **调度器线程控制**： 确保调度器能够正确地启动、执行任务并在最后停止。
4. **验证调度顺序**： 通过观察任务的输出，可以验证任务是否在期望的线程中执行，并且任务是否按顺序调度。
5. **扩展测试**：
   - 可以尝试不同数量的工作线程（比如设置为4个或更多），验证调度器的扩展性。
   - 调整任务的数量和调度频率，验证调度器在高负载下的表现。

通过这些测试，能够确认调度器和协程任务的调度是否如预期工作，协程的执行是否线程安全，并且能够在不同的线程之间协调任务。

###### `iomanager`

**验证非阻塞 I/O**：

- 确保 `recv` 和 `send` 操作在非阻塞模式下正确工作，并且事件能够在适当时机触发回调函数。

**事件处理验证**：

- 测试连接建立、请求发送和响应接收是否按照预期顺序执行。
- 可以尝试不同的服务器和请求内容，验证网络通信是否稳定。

**错误处理验证**：

- 在网络故障或服务器不可用的情况下，检查程序是否能够正确处理 `EAGAIN` 等错误，并能够在下一次事件循环中继续执行。

**多事件并发处理**：

- 扩展代码，添加多个套接字或任务，验证 `IOManager` 是否能够正确处理并发的 I/O 事件。

###### timer

程序首先添加 10 个非循环定时器，这些定时器的触发时间依次为 1 秒、2 秒、3 秒……，它们的回调会输出不同的 `i` 值（0, 1, 2, ..., 9）。

然后，程序暂停 5 秒，触发并执行到期的定时器回调函数。

再暂停 5 秒，触发其余的定时器回调函数。

接着，程序添加一个每秒触发的循环定时器，并且每秒检查定时器的状态并执行已过期的回调，持续 10 秒钟。

###### 综合

程序启动后，调用 `test_iomanager` 创建并初始化套接字。

启动事件循环，监听端口 `8080` 上的连接。

一旦有连接请求，`test_accept` 被调用，接受连接并为其创建新的事件处理。

当客户端发送数据时，事件管理器会触发读取事件并通过回调读取数据。

响应数据后，关闭连接并准备接受下一个连接。



### Apache Bench

`ab`（Apache Bench）是一个由 Apache HTTP 服务器提供的命令行工具，用于进行 HTTP 性能测试。它能够模拟多个并发的客户端请求，以评估 HTTP 服务器的处理能力，特别是在高并发情况下的响应时间和吞吐量。

###### 主要功能

`ab` 主要用于测试 Web 服务器的性能，它通过模拟多个并发请求来产生负载，常用于压力测试和基准测试。`ab` 可以测量以下几项指标：

- **吞吐量（Throughput）**：单位时间内服务器处理的请求数量。
- **响应时间（Response Time）**：服务器响应请求的时间，通常以平均响应时间、最小响应时间和最大响应时间来表示。
- **并发连接数（Concurrency）**：并发请求的数量，用于测试服务器在多客户端并发情况下的性能。
- **成功请求数**：服务器成功处理的请求数。

###### 常用命令参数

```bash
ab -n [请求总数] -c [并发数] [URL]
```

- **-n [请求总数]**：指定总共要发送的请求数量。例如，如果设置为 `1000`，`ab` 会发送 1000 次请求到目标服务器。
- **-c [并发数]**：指定同时发起请求的并发连接数。例如，设置为 `10`，意味着同时有 10 个请求并行发送。
- **[URL]**：要测试的目标 URL。例如，`http://localhost/index.html`。

###### 示例

假设你要对 `http://localhost/` 进行压力测试，发送 1000 个请求，并且设置 10 个并发连接：

```bash
ab -n 1000 -c 10 http://localhost/
```

这个命令会生成 1000 个 HTTP 请求，并且这些请求会被 10 个并发连接同时发送给服务器。测试结束后，`ab` 会输出统计结果，包括吞吐量、响应时间、成功请求数等。

###### 结果解释

执行 `ab` 后，你将看到类似如下的输出：

```
Server Software:        Apache/2.4.6
Server Hostname:        localhost
Server Port:            80

Document Path:          /
Document Length:        12345 bytes

Concurrency Level:      10
Time taken for tests:   2.345 seconds
Complete requests:      1000
Failed requests:        0
Total transferred:      12345678 bytes
HTML transferred:       12345 bytes
Requests per second:    426.32 [#/sec] (mean)
Time per request:       23.45 [ms] (mean)
Time per request:       2.34 [ms] (mean, across all concurrent requests)
Transfer rate:          534.56 [Kbytes/sec] received
```

其中，常见的关键数据包括：

- **Requests per second**：平均每秒请求数，反映了服务器的吞吐量。
- **Time per request**：每个请求的平均响应时间。
- **Failed requests**：失败的请求数，理想情况下应为 0。
- **Concurrency Level**：并发连接数，表示在测试过程中同时请求的数量。

###### 使用场景

1. **性能基准测试**：用于测试 Web 服务器在不同并发下的表现。
2. **负载测试**：模拟多个并发客户端访问，帮助识别服务器在高负载下的瓶颈。
3. **优化和调优**：通过 `ab` 输出的结果来进行服务器性能的优化。例如，减小响应时间、提高吞吐量等。

###### 注意事项

- **请求的资源**：`ab` 发送的 HTTP 请求是针对指定 URL 的，目标 URL 中的内容类型、大小等因素会影响测试结果。如果需要测试的是静态资源，可以使用相对较大的文件进行测试，以模拟更真实的负载。
- **网络带宽**：网络带宽可能成为性能瓶颈，尤其是当大量并发请求通过单一网络连接时。
- **服务器配置**：服务器配置（如最大连接数、CPU 性能、内存等）会显著影响性能测试结果。
- **负载过大**：不要一次性过度加载服务器，这可能会导致服务器崩溃或服务不可用。

###### 小结

`ab` 是一个强大且简单的性能测试工具，它可以快速生成负载并评估 Web 服务器的响应能力。虽然它功能简单，但可以满足基础的性能基准测试需求，对于大规模的负载测试，可以考虑使用更复杂的工具如 `JMeter` 或 `Gatling`。
