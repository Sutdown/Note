#####  c++****

- [ ] 程序员的自我修养
- [ ] C++ Prime
- [ ] 深入探索c++对象模型
- [x] 深入理解c++11
- [x] STL源码剖析

###### 1.静态变量和全局变量局部变量的区别，内存如何分布。

static（代码区，全局/静态区（bss未初始化，数据段已初始化），栈区，堆区）

###### 2.指针和引用

指针存放某个变量的地址，本身属于命名的变量。引用就是变量的别名。

###### 3.c++内存分区

从低到高：代码区，全局/静态区（bss未初始化，数据段已初始化

###### 4.static和const关键字作用

static：控制变量和函数的生命周期，作用域以及访问权限。

（静态成员函数属于类，不属于对象，自身有隐含的this指针，因此能够直接访问静态成员变量，但是不能直接访问普通成员变量。）

const：用于指定变量，指针，引用，成员函数等的性质。

###### 5.常量指针和指针常量

指针本身是常量，指针不可变，指针指向的内容可变；指针指向的内容是常量，可以修改指针。

###### 6.智能指针的实现原理

智能指针是管理动态内存的对象，主要目的在于避免内存泄露和方便资源管理。原理为RALL。

###### 7.new和malloc的区别

###### 8.delete和free

new和delete的底层是malloc，先malloc分配内存，再调用构造函数，返回指针，调用析构，free释放内存。所以new通常在c++中比malloc更安全。

new（分配空间，返回指针，抛出异常）malloc（分配指定大小内存块，需要类型转换，失败返回NULL）

delete（调用析构函数，释放的指针设置为nullptr）free（释放内存块）

###### 9.堆和栈

栈：一般存档局部变量，形参，返回值等，生命周期与所在函数生命周期相同，由编译器控制。

堆：动态分配的内存区域，由程序员分配内存和释放。

###### 10.内存泄露是什么，如何检测和防止

内存泄露是指程序未能释放掉不再使用的内存的情况。

可能出现的情况：

堆内存泄露，系统资源泄露，没有将基类的析构函数定义为虚函数。

如何检测：valgrind(插入一个虚拟化层，模拟cpu执行代码，拦截所有的内存操作，检查内存问题），addressSanitizer（编译时插桩，通过修改程序的二进制代码检测内存问题）

如何防止：RALL，智能指针

###### 11.野指针是什么，如何避免

野指针是指指向已经被释放或者无效内存地址的指针。可能导致程序崩溃，数据损坏等其它不可控行为。

情况：释放后没有空置指针，返回局部变量的指针，函数参数指针被释放

如何避免：使用智能指针，注意函数参数的生命周期

###### 12.c++面向对象三大特性

封装，继承，多态

###### 13.c++的重载和重写，区别和实现方式

重载：函数名相同，参数列表或者类型不同，同一个函数名有多个版本。

重写：派生类重新覆盖基类中的虚函数，以提供特定于派生类的实现。

###### 14.c++多态的底层实现

[多态是什么](https://developer.aliyun.com/article/1363172) 1.基类指针，2.重写

通过虚函数和虚函数表实现。多态性允许基类类型的指针或引用上调用派生类对象的函数，以便在运行时选择正确的函数实现。

1.基类声明虚函数，派生类重写虚函数

2.使用基类类型指针或引用指向派生类对象，然后可以调用虚函数

3.编译器在对象的内存布局中维护了一个虚函数表，其中存储了指向实际函数的指针。

###### 15.虚函数和纯虚函数区别

纯虚函数类似于一种接口规范，没有实现，只有声明，派生类必须提供纯虚函数的实现（=0）。

###### 16.虚函数如何实现

虚函数的实现主要依赖于 **虚函数表**（**vtable**）和 **虚函数指针**（**vptr**）

###### 17.虚函数表是什么

虚函数表（**vtable**）是 C++ 中实现多态性（尤其是运行时多态性）的关键机制。它是编译器在处理包含虚函数的类时用来支持动态绑定（即运行时决策调用哪个函数）的数据结构。

###### 18.构造函数和析构函数是什么，它们可以是虚函数吗

虚析构函数允许在运行时根据对象的实际类型调用正确的析构函数，从而实现多态性。
虚函数–>多态–>动态绑定(运行时)

不能被声明为虚函数：普通函数，静态成员函数，内联成员函数，构造函数，友元函数

###### 19.c++有几种构造函数，分别什么作用

有参，无参，拷贝，移动，委托构造函数

###### 20.深拷贝和浅拷贝

深拷贝是对对象的完全独立复制，包括对象内部动态分配的资源，一般需要手动分配内存。浅拷贝仅复制队形的值，和元对象共享资源。

###### 21.stl容器

stl有六个组件：**算法，容器，迭代器**，仿函数，适配器，空间配置器

容器真正的底层只有vector, list，deque，RBtree，hashtable

###### 22.vector和list区别

数组，双向链表

###### 23.vector底层原理和扩容过程

底层是数组，实现包含一个指向数组起始位置的指针，数组的大小和容量等信息。
扩容：集合已满在增添新数据的时候，需要分配更大的内存。

###### 24.push_back()和emplace_back()

push_back 将已经存在的元素作为参数，拷贝到容器的末尾
emplace_back 完美转发避免了多余的拷贝操作

###### 25.map deque list实现原理

list(双向迭代器，双向链表)，deque(随机存取迭代器，看起来和无非是vector多加了一边开口，实际底层分配了一块缓冲区，其中的每个结点指向一块连续的内存空间，因此造成了虚假的随机存取的假象)，map底层（RBtree）

###### 26.map unordered_map区别和实现机制

[map unordered_map](https://www.cnblogs.com/yimeixiaobai1314/p/14375195.html)

[c++面试摘录（二） unordered_map和map的底层原理](https://blog.csdn.net/weixin_61207303/article/details/123402294)

map底层：RBtree红黑树可以自动排序，也就是非严格平衡的二叉搜索树；

unordered_map底层：哈希表，内部元素杂乱无序，查找删除添加的速度快冲突（开放寻址法，链地址法，公共溢出区）。

- [ ] 看看红黑树源码

###### 27.c++11新特性

基础的语法完善：比如friend的扩充，final/override，右值引用，SFINEA规则，auto，decltype，智能指针，线程局部存储，指针控制，基于范围的for循环等等

###### 28.移动语义的作用和原理

右值引用是移动语义的核心，主要进行的是资源的转移，利用移动构造函数

通过右值引用，移动构造函数，移动赋值运算符实现

###### 29.左值引用和右值引用区别

###### 30.lambda函数

表示一个可调用的代码单元，没有命名的内联函数，不需要函数名

由捕获列表，参数列表，返回类型，函数体构成

###### 31.c++实现[单例模式](https://github.com/Sutdown/Note/blob/main/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%981-2.md)

```cpp
class Singleton{
    public:
    // C++11 及以上标准规定，局部静态变量在多线程环境中是线程安全的。
    staic Singleton& getInstance(){
        static Singleton instance;
        return instance;
    }
    
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
}
```

###### 32.菱形继承是什么

```css
        A
       / \
      B   C
       \ /
        D
```

二义性：D调用从A继承的方法时，不知道是通过B继承还是C继承

重复继承：D拥有B和C各自继承A的副本，会产生不必要的内存浪费

解决方案：虚继承

B和C共享A的虚函数表，并且自己会有虚函数表存储B和C各自重写的虚函数地址。虚函数表中会有指针指向A的表。

###### 33.c++中的多线程同步机制

互斥锁，读写锁都是基本的同步原语，条件变量。atomic原子操作

###### 34.如何在c++中创建和管理线程

thread线程类，支持对线程的创建，管理和同步

join等待线程完成，detach让线程独立指向，mutex避免竞争条件，condition\-variable实现线程间信号传递

###### 35.sizeof

返回一个对象或者类型名的字节长度

###### 36.手写vector，哈希表



待办：

- [ ] Effective STL
- [ ] Effective C++



##### **Mysql**

- [x] mysql是怎样运行的
- [x] mysql必知必会

###### 1.事务的四大特性

ACID

###### 2.事务的隔离级别

读未提交，读已提交，可重复读，串行化

###### 3.一条sql查询语句如何进行

连接器，查询缓存，解析sql，执行sql

###### 4.mysql的执行引擎

存储引擎主要是InnoDB，采用B+树作为索引

###### 5.为什么用b+树做索引

相比B树：

- 由于冗余结点较多，增删改时不会出现太大的变动
- 只有叶子结点存放数据，能够存放更多的索引，减少磁盘IO次数
- 叶子节点之间用链表连接，有利于范围查询。

###### 6.索引失效的场景

**优化索引的方式**：前缀索引优化，覆盖索引优化，主键索引最好自增，索引最好设置为Not Null，防止索引失效

**索引失效的场景：**不符合最左匹配，不符合列前缀，匹配范围值，不符合索引的排序or分组，表达式计算

###### 7.undo log,redo log, binlog的作用

- undo log：原子性，事务回滚和MVCC
- redo log：持久性，用于掉电等故障恢复
- binglog：归档日志，server层生成，用于数据备份和主从复制。

###### 8.慢查询是什么？原因是什么？如何优化？

原因：索引缺失或者不合理；查询复杂；数据量过大；锁竞争；

优化：添加索引，优化查询；为表分表和分区（如果表过大）

###### 9.MVCC是什么

多版本并发控制

###### 10.缓存雪崩，击穿，穿透和解决办法

[什么是缓存雪崩、击穿、穿透？ | 小林coding](https://xiaolincoding.com/redis/cluster/cache_problem.html)

###### 11.如何保证数据库和缓存的一致性

[数据库和缓存如何保证一致性？ | 小林coding](https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html)

###### 12.锁（死锁）

**基础的锁**：

- 互斥锁：由内核实现，有两次上下文切换的成本，加锁失败后线程释放CPU，给其它线程

- 自旋锁：由CAS函数实现，在用户态完成加锁和解锁，开销小，加锁失败后，线程忙等，直到它拿到锁。（抢占式）

**读写锁**

**[乐观锁和悲观锁](https://www.cnblogs.com/kismetv/p/10787228.html)**

- 乐观锁：只在执行更新的时候判断他人是否修改数据

  实现机制：CAS和版本号机制(本身不加锁)

- 悲观锁：一旦操作数据都会直接把数据锁住

  实现机制：对代码块加锁，或者对数据加锁

**死锁**

互斥，请求保持，不可剥脱，环路等待

##### **OS**

- [ ] 操作系统导论
- [ ] 现代操作系统

###### 1.进程和线程的区别

定义，资源，通信和同步，安全性

[进程、线程、协程常见面试题汇总_牛客网](https://www.nowcoder.com/discuss/353157556447158272)

线程切换都是在进程的虚拟地址空间中变换，进程切换需要将虚拟地址转换成物理地址，这个需要查找页表，页表切换后TLB失效，cache失效命中率变低，程序运行失效

###### 2.并行和并发的区别

并行：多个核心同时执行多个进程

并发：单个核心短时间执行多个进程

###### 3.解释一下用户态和核心态

用户态：程序或者进程只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源

核心态：属于操作系统的特权级别，允许进程或者程序执行特权指令，访问操作系统的核心部分。此时进程可以直接访问硬件资源，执行系统调用，管理内存，文件系统等操作。

（系统调用，异常，中断）

###### 4.进程调度算法

批处理系统：FIFO，SJF，最短剩余时间优先

交互式系统：时间片轮换，多级反馈队列调度，优先级调度

###### 5.进程间通信方式

基于内存：匿名管道，信号量，消息队列，共享内存

基于网络：socket，消息队列，RPC等

###### 6.进程同步和互斥是什么，如何实现

进程同步：协调多个进程间的执行顺序，以按照某种预期的时序进行。信号量，条件变量，消息队列，管道等

进程互斥：确保多个进程不能同时访问共享资源。互斥锁，自旋锁，信号量，禁用中断等

###### 7.死锁是什么，如何预防死锁

死锁：两个或者多个进程争夺系统资源时，由于互相等待对方释放资源而无法继续执行的状态

条件：互斥，请求保持（一次险申请所有的资源），不可剥脱（主动释放），环路等待（设置申请资源的顺序）

###### 8.介绍一下几种经典的锁

基础：互斥锁，自旋锁

其它：读写锁，悲观锁，乐观锁

###### 9.虚拟内存是什么，如何理解

用于为进程提供一个抽象的、连续的内存地址空间，使得进程可以不直接访问物理内存。

分页，分段

###### 10.线程同步的方式

[基本功 | 一文讲清多线程和多线程同步](https://tech.meituan.com/2024/07/19/multi-threading-and-multi-thread-synchronization.html)

互斥锁，条件变量，读写锁，信号量

###### 11.页面置换算法

LRU，FIFO，最佳页面置换算法，时钟页面置换算法，最不常用算法

###### 12.熟悉哪些linux口令

ls,cd,pwd,touch,mkdir,rm,cp,mv,cat,vi,

head,tail,grep,find,chmod,chown,

ps,kill,df,tar,ifconfig,ping,ssh,apt.yum

###### 13.如何查看端口有没有被占用

netstat -tulu | grep <端口号> 有输出说明端口被占用

ss -tuln | grep <端口号> 直接通过套接字和内核通信，更快，支持更多的网络信息

###### 14.说一下select，poll和epoll，边缘触发水平触发

[I/O 多路复用：select/poll/epoll](https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html)

[红黑树深入剖析及Java实现](https://tech.meituan.com/2016/12/02/redblack-tree.html)

线性结构（文件描述符集合），链表（受系统文件描述符限制），红黑树+链表

###### 15.僵尸进程是什么，为什么会产生

[fork()函数详解 - _NewMan - 博客园](https://www.cnblogs.com/love-jelly-pig/p/8471206.html)

子进程打算退出但是没有完全退出时的状态为僵尸进程，此时发生的原因是因为要等父进程读取完状态。僵尸进程的目的是维护子进程的信息，状态等

孤儿进程：一个父进程退出，但是子进程还在运行，子进程变成孤儿进程，由init进程收养，完成剩下的状态收集。

fork调用后，会出现两个进程，一个子进程返回0，附近拿出返回子进程的ID



管道，匿名管道，信号量，消息队列，共享内存，信号，socket



##### 计网

- [ ] linux内核设计
- [ ] 网络是怎样连接的
- [ ] 图解TCP/IP
- [ ] 图解HTTP
- [ ] 深入理解linux网络
- [x] HTTP权威指南

###### 1.TCP/IP模型和OSI模型

应用层，传输层（TCP/UDP），网络层（IP转发和路由），数据链路层（封装成帧，差错检测，可靠传输），物理层

在应用层和传输层之间增加了表示层和会话层

###### 2.从输入URL到页面展示发生了什么，以及用到的协议

解析URL构建HTTP请求；DNS域名解析；建立TCP连接；发生HTTP/HTTPS请求到web服务器；服务器处理请求返回HTTP报文；浏览器渲染界面；断开连接四次挥手

DNS，TCP，IP，OPSF，ARP，HTTP

###### 3.HTTP请求报文和响应报文是怎样的

请求报文：
请求行（请求方法，URL，版本号），请求头（Host，User-Agent，Accept，Content type。Authorization），空行，请求体（请求的实际数据）

响应报文：
状态行（HTTP协议版本，状态码，状态消息）响应头部（Content type，content length，content encoding，server，location，set cookie）空行，相应主体（响应的实际数据）

###### 4.HTTP请求方式有哪些

GET,POST,HEAD,PUT,DELETE,TRACE,PATCH,CONNECT,OPTIONS

###### 5.GET请求和POST请求的区别

GET：申请资源，写在URL之中，安全且幂等，会被主动缓存，只支持URL编码

POST：提交数据，放在请求体中，不安全不迷等，支持多种编码

###### 6.HTTP中常见的状态码

1xx提示信息，协议处理中间状态，2xx请求成功(200,204,206)，3xx请求重定向（304，301，302），4xx请求错误（404，401，403），5xx服务器错误（500，503）

###### 7.什么是强缓存和协商缓存

[协商缓存与强缓存 | 前端进阶小书](https://zxpsuper.github.io/Demo/advanced_front_end/browser/cache.html)

强制缓存：浏览器判断请求的目标资源是否有效命中强缓存。
Expires；cache control通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期200

协商缓存：浏览请中请求响应码为304时，说明可以使用本地缓存的资源，这种通过服务端告知客户端是否可以使用缓存的方式称为协商缓存。

- `if modified since`和`last modified` 请求时带上`if modified since`如果`last modified`比其小，响应304走缓存，如果大，返回最新资源。
- `if none match`和`ETag`浏览器第一次访问服务器资源时，服务器会在返回该资源同时在`Response`头部加上`ETag`唯一标识，ETag类似于`last modified`的作用，但是时间是不一定精确的，可能导致错误

###### 8.HTTP1.0和HTTP1.1的区别

简单灵活易于扩展

HTTP1.0：引入请求头和响应头，支持多种请求方法和状态码；不支持持久连接，每次请求都需要新的连接

HTTP1.1：长连接；管道网络传输（解决了请求的队头阻塞，没有解决相应的队头阻塞）；头部冗余，只能客户端开始等

###### 9.HTTP2.0和HTTP1.1的区别

HTTP2.0：相对于1.1增加了HPack压缩算法（减少头部传输的数据量，降低延迟）；引出**stream**概念，将多个stream复用成一条TCP连接，可以并行交错发送请求和相应；依然存在队头阻塞，但是解决了1.1的问题，是在传输层；ASCII编码更改为二进制编码

###### 10.HTTP3.0是什么

将下层的TCP协议改成了基于**QUIC协议的UDP**，QHACK–》QPACK

没有队头阻塞（流与流之间不会互相影响），更快的连接建立（TCP三次握手和TLC四次握手），连接迁移

###### 11.HTTPS和HTTP的区别

HTTP为明文传输，HTTPS增加了TLS/SSL安全协议，使得保温能够加密传输

HTTPS在TCP三次握手之后，还需要SSL/TLS的握手过程才可以加密保温传输

HTTP端口80，HTTPS端口号443

HTTPS需要想CA申请数字证书，确保服务器身份可信

###### 12.HTTPS的工作原理

SSL(Secure Socket Layer) / TSL(Transport Layer Security)

信息加密（对称加密+非对称机密），校验机制（摘要算法，数字签名），身份证书（CA）

###### HTTPS的通信过程

SSL/TLS协议流程：

- 客户端向服务器索要并且验证服务器的公钥

- 双方协商产生会话密钥

- 双方采用会话密钥进行加密通信


###### 13.TCP和UDP的区别

TCP：面向连接的，可靠的数据流传输；传输单位TCP报文段；安全性更好；有复杂的连接状态表，适用于对于传输准确性要求高的场景

UDP：非面向连接的，不可靠的数据流传输；传输单位用户数据报；速度更快；无状态，适用于即使通信

TCPh和头部TTP

###### 14.TCP连接如何确保可靠性

重传（超时重传，快速重传，SACK，D-SACK），

滑动窗口（发送窗口，接收窗口），

流量控制（缓存区和窗口，窗口关闭，糊涂窗口综合征），

拥塞控制（慢启动，拥塞避免，拥塞发生，快速恢复）

###### 15.UDP如何实现可靠传输

HTTP3.0，基于QUIC的UDP[如何基于 UDP 协议实现可靠传输？ | 小林coding](https://www.xiaolincoding.com/network/3_tcp/quic.html)

###### 16.三次握手的过程，为什么是三次

三次握手可以保证双方都具有接收和发送的能力。

半连接队列（SYN队列），全连接队列（Accept队列）—>SYN攻击

###### 17.四次挥手的过程，为什么是四次

服务端等待数据的发送和处理。     

Time wait1.防止历史连接中的数据被后面相同的四元组接收2.保证最后一个ACK能放被动关闭方接收

###### 18.HTTP的Keep-Alive是什么，TCP的Keepalive和HTTP的keep-Alive是一个东西吗

HTTP：配置长连接，客户端和服务端完成一个HTTP请求和响应时，不会立即关闭，而是继续保持连接位于打开状态，然而长时间的持久连接可能占用服务器资源；

TCP：由TCP层（内核态）实现，称为TCP保活机制。这个主要是发送特定的数据包维护连接的活跃性，目的在于检测连接是否处于空闲状态。

###### 19.DNS查询过程

浏览器缓存，本机host文件，本地DNS服务器；

本地DNS服务器，根DNS服务器，顶级域名DNS服务器，权威DNS服务器，缓存

迭代查询，递归查询

###### 20.CDN是什么

[面试官：如何理解CDN？说说实现原理？ | web前端面试 - 面试官系列](https://vue3js.cn/interview/http/CDN.html)

`content delivery network`在域名解析时，如果开启CDN，DNS会解析离用户最近的CDN结点的IP地址，然后将其分发到最适合的服务器结点上。（就近访问）缓存静态资源，热门内容等（内容缓存，前置缓存）同时也会考虑服务器的负载和可用性（只能负载均衡），另外（压缩，并行）

###### 21.Cookie和Session是什么，有什么区别

cookie：在客户端记录信息确定用户身份，是服务端发送存储在本地用户浏览器的小型文本文件。

session：在服务端记录信息确定用户身份。用于维护用户登录状态，存储用户临时数据，上下文信息等。会话标识符，记录当时的会话活动，时间等。

###### 22.TCP如何处理沾包拆包问题

沾包拆包的产生原因：写入数据大于套接字缓冲区大小或者大于TCP一次的最大报文长度时，会拆包。小于缓冲区大小，或者接收不及时会沾包。

处理拆包：1）在包头添加信息注定包长，只有到达指定包长时才说明获取完整；2）指定包的结束标志

处理沾包：1）关闭nagal算法 2）指定每条数据的开头和结束标识符 或者 根据长度判断每个分组的开始和结束

###### 23.单点登录

普通认证机制：登录认证成功后，服务器把用户的登录信息写入session，并为该用户生成一个cookie，返回并写入浏览器，当用户再次访问时，请求中会带上这个cookie，服务端根据这个cokie找到session，判断这个用户是否登录。

单点登录：允许用户在一次登录后访问多个关联的应用程序或者服务，而无需再次输入凭据。

[单点登录（SSO）的设计与实现 - Ken的杂谈](https://ken.io/note/sso-design-implement)




##### tool

- [ ] 大话设计模式
- [x] 汇编语言
- [ ] c++语言的设计和演化
- [ ] 深入理解c++系统

###### 1.docker的原理

docker的本质是：container format 将namespace（提供容器的工作空间），control groups（限制，分离，控制一个进程组的资源），和union file system（联合文件系统）进行封装。

###### 2.git基本命令，git如何合并，merge和rebase区别

git merge 将两个分支的最新提交合并成一个新的合并提交，合并后的历史为树状，保留所有的分支信息。

git rebase 将本地未push的分叉提交历史整理成直线，重交提交历史，从而使得历史更加线性。

###### 3.ping

测试网络连通性和网络延迟

原理在于利用ICMP协议（网络传输控制协议），位于网络层，向目标主机发送请求消息再返回



##### other

###### 1.协程ucontext的实现

###### 2.linux查看内存有多少

free -h 可以查看空闲内存

top可以实时监控系统资源的工具

###### 3.线程池的实现

[Java线程池实现原理及其在美团业务中的实践 - 美团技术团队](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)

核心线程数，最大线程数，空闲线程的存活时间，任务队列

###### 4.乐观锁和悲观锁

###### 5.单元测试的原理，如何不影响其它功能或者层

###### 6.视频面试用到的协议

###### 7.线程安全的单例类

###### 8.手写`share_ptr`

###### 9.虚函数

###### 10.手写哈希表

###### 11.排序（手写快排）

DNS，HTTP，HTTPS，TCP，UDP



##### 阅读

###### linux内核设计书籍阅读

- [ ] 1linux内核简介
- [ ] 2内核出发
- [ ] 3进程管理
- [ ] 4进程调度
- [ ] 5系统调用
- [ ] 6内核数据结构
- [ ] 7中断
- [ ] 8下半部
- [ ] 9内核同步
- [ ] 10内核同步方法
- [ ] 11定时器和时间管理
- [ ] 12内存系统
- [ ] 13虚拟文件系统
- [ ] 14块IO层
- [ ] 15进程地址空间
- [ ] 16页高速缓存和页回写
- [ ] 17设备和模块
- [ ] 18调试
- [ ] 19可移植性
- [ ] 20补丁开发社区



##### 算法

- [x] LRU