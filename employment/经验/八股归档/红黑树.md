# 红黑树详解



红黑树是平衡二叉查找树的一种。



1.什么是平衡二叉查找树

二叉查找树特征：父节点的左子节点比父节点小，右子节点比父结点大。同时中序遍历的结果为从小到大的排序的。

平衡二叉查找树是为了尽量保障树的高度在`logN`(N为结点的总数量)，代表为AVL树和红黑树。



2.RBTree的特点是什么

`RBTree`特点是

- 每个结点都分为红色和黑色，
- 根节点是黑色的，
- 父子结点间不能出现两个连续的红节点，
- 所有从根节点到叶子结点所经过的路径上的黑节点的个数是相同的



3.红黑树是最为简单的一种平衡二叉查找树，它是如何诞生的

1）明确：平衡二叉查找树是为了解决二叉查找树很容易发生树倾斜的问题产生的。那如果想达到平衡的目的，需要解决在插入结点时二叉查找树的倾斜问题，那该如何解决呢。

2）解决1：AVL树，也就是常说的严格的平衡二叉查找树，每个结点有一个严格的平衡因子（左子树高度-右子树高度），这个平衡因子只能为0，-1，1。每进行一次增删改操作，都需要对整棵树进行遍历，这是极为复杂的。

3）解决2：红黑树。这个的具体诞生方法其实跟B树有一定的关联，感兴趣可以看看这篇文章[红黑树是怎么来的 ](https://www.cnblogs.com/linvanda/p/17400505.html)，讲的很好，我这里大致说下。二叉树的产生是由于对2-3树（一个结点最多可能有2或3个子节点）的变换，2-3树在结点数大于3时会向上裂变，这应该是为了抵御二叉查找树倾斜时的向下列变，仿照2-3树的思想，将2结点和3结点等价成二叉树的形式，同时由于2结点和3结点是需要变换的，将边中靠下的结点设为红节点，其余设置为黑节点。因此可以得出**不可能存在两个连续的红节点**的结论，同时，依据23树中，将为2个结点中的一个结点设置为红色并且2-3树的左右子树高度相等，因此**所有从根节点到叶子结点的黑结点数目一定相同**，由于默认设置两个元素中小的结点为红色，大的结点为黑色，同时限制红线往左倾，因此**根节点一定是黑色的**。3结点在转换成2个节点时，可能增加树的高度，所以红黑树只是近似的二叉平衡树。



4.红黑树如何进行增删

准备工作：

为了保障在增删节点时，保障平衡性，引申出两个操作

- 左旋和右旋，左右旋转的同时不会改变二叉树特性
- 翻转颜色

增：

由于需要保障每条路径黑色结点个数相同，因此插入结点为红色，再利用翻转，左旋和右旋保证特性。

- 父节点为黑色时，不违反任何性质
- 父节点和叔结点均为红色。采取翻转颜色
- 父节点为红色，叔结点为黑色，且插入结点为左节点。对其父结点进行一次右旋，同时修改颜色。（插入节点和父节点均为红色，说明需要向上裂变了，（左倾二叉树））
- 父节点为红色，叔结点为黑色，且插入节点为右节点。先对父节点进行一次左旋，然后变成上面的情况。

删：

只有在黑色结点被删除时，才需要调整。

- 被删除结点没有子节点，直接删除，修改父节点
- 被删除结点只有一个子节点，将子节点提升到被删除结点的位置，修改父结点
- 被删除结点有两个结点
  - 被删除结点的下一个结点位于右结点中，且右节点没有左结点，右节点代替被删除结点
  - 被删除结点的下一个结点位于右结点的左结点中，用该节点替换被删除结点

调整之后，再通过旋转和重新着色（均发生在违背性质时的操作）等修正，使之重新成为一个红黑树。



参考文章：

1.[红黑树深入剖析及Java实现](https://tech.meituan.com/2016/12/02/redblack-tree.html)

2.[红黑树是怎么来的 ](https://www.cnblogs.com/linvanda/p/17400505.html)

3.[红黑树-wiki](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)